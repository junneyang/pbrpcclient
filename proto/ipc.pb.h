// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ipc.proto

#ifndef PROTOBUF_ipc_2eproto__INCLUDED
#define PROTOBUF_ipc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace lbs {
namespace da {
namespace openservice {
namespace ipc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ipc_2eproto();
void protobuf_AssignDesc_ipc_2eproto();
void protobuf_ShutdownFile_ipc_2eproto();

class ProcessorConnectRequest;
class HeartBeatNotify;
class RedisRequest;
class RedisResponse;
class StatItem;
class StatReport;
class ProcessorUpgrade;
class ChangeLogLevel;

// ===================================================================

class ProcessorConnectRequest : public ::google::protobuf::Message {
 public:
  ProcessorConnectRequest();
  virtual ~ProcessorConnectRequest();
  
  ProcessorConnectRequest(const ProcessorConnectRequest& from);
  
  inline ProcessorConnectRequest& operator=(const ProcessorConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorConnectRequest& default_instance();
  
  void Swap(ProcessorConnectRequest* other);
  
  // implements Message ----------------------------------------------
  
  ProcessorConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessorConnectRequest& from);
  void MergeFrom(const ProcessorConnectRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string from_processor = 1;
  inline bool has_from_processor() const;
  inline void clear_from_processor();
  static const int kFromProcessorFieldNumber = 1;
  inline const ::std::string& from_processor() const;
  inline void set_from_processor(const ::std::string& value);
  inline void set_from_processor(const char* value);
  inline void set_from_processor(const char* value, size_t size);
  inline ::std::string* mutable_from_processor();
  inline ::std::string* release_from_processor();
  
  // required int32 from_idx = 2;
  inline bool has_from_idx() const;
  inline void clear_from_idx();
  static const int kFromIdxFieldNumber = 2;
  inline ::google::protobuf::int32 from_idx() const;
  inline void set_from_idx(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.ProcessorConnectRequest)
 private:
  inline void set_has_from_processor();
  inline void clear_has_from_processor();
  inline void set_has_from_idx();
  inline void clear_has_from_idx();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* from_processor_;
  ::google::protobuf::int32 from_idx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static ProcessorConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatNotify : public ::google::protobuf::Message {
 public:
  HeartBeatNotify();
  virtual ~HeartBeatNotify();
  
  HeartBeatNotify(const HeartBeatNotify& from);
  
  inline HeartBeatNotify& operator=(const HeartBeatNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatNotify& default_instance();
  
  void Swap(HeartBeatNotify* other);
  
  // implements Message ----------------------------------------------
  
  HeartBeatNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatNotify& from);
  void MergeFrom(const HeartBeatNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.HeartBeatNotify)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static HeartBeatNotify* default_instance_;
};
// -------------------------------------------------------------------

class RedisRequest : public ::google::protobuf::Message {
 public:
  RedisRequest();
  virtual ~RedisRequest();
  
  RedisRequest(const RedisRequest& from);
  
  inline RedisRequest& operator=(const RedisRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisRequest& default_instance();
  
  void Swap(RedisRequest* other);
  
  // implements Message ----------------------------------------------
  
  RedisRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedisRequest& from);
  void MergeFrom(const RedisRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  
  // required bytes shardkey = 2;
  inline bool has_shardkey() const;
  inline void clear_shardkey();
  static const int kShardkeyFieldNumber = 2;
  inline const ::std::string& shardkey() const;
  inline void set_shardkey(const ::std::string& value);
  inline void set_shardkey(const char* value);
  inline void set_shardkey(const void* value, size_t size);
  inline ::std::string* mutable_shardkey();
  inline ::std::string* release_shardkey();
  
  // repeated bytes args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const void* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();
  
  // required bool readonly = 4;
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadonlyFieldNumber = 4;
  inline bool readonly() const;
  inline void set_readonly(bool value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.RedisRequest)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_shardkey();
  inline void clear_has_shardkey();
  inline void set_has_readonly();
  inline void clear_has_readonly();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* source_;
  ::std::string* shardkey_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  bool readonly_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static RedisRequest* default_instance_;
};
// -------------------------------------------------------------------

class RedisResponse : public ::google::protobuf::Message {
 public:
  RedisResponse();
  virtual ~RedisResponse();
  
  RedisResponse(const RedisResponse& from);
  
  inline RedisResponse& operator=(const RedisResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedisResponse& default_instance();
  
  void Swap(RedisResponse* other);
  
  // implements Message ----------------------------------------------
  
  RedisResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedisResponse& from);
  void MergeFrom(const RedisResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional int64 intv = 2;
  inline bool has_intv() const;
  inline void clear_intv();
  static const int kIntvFieldNumber = 2;
  inline ::google::protobuf::int64 intv() const;
  inline void set_intv(::google::protobuf::int64 value);
  
  // optional double floatv = 3;
  inline bool has_floatv() const;
  inline void clear_floatv();
  static const int kFloatvFieldNumber = 3;
  inline double floatv() const;
  inline void set_floatv(double value);
  
  // optional bytes str = 4;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 4;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const void* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  
  // repeated .lbs.da.openservice.ipc.RedisResponse elements = 5;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 5;
  inline const ::lbs::da::openservice::ipc::RedisResponse& elements(int index) const;
  inline ::lbs::da::openservice::ipc::RedisResponse* mutable_elements(int index);
  inline ::lbs::da::openservice::ipc::RedisResponse* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::RedisResponse >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::RedisResponse >*
      mutable_elements();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.RedisResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_intv();
  inline void clear_has_intv();
  inline void set_has_floatv();
  inline void clear_has_floatv();
  inline void set_has_str();
  inline void clear_has_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 intv_;
  double floatv_;
  ::std::string* str_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::RedisResponse > elements_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static RedisResponse* default_instance_;
};
// -------------------------------------------------------------------

class StatItem : public ::google::protobuf::Message {
 public:
  StatItem();
  virtual ~StatItem();
  
  StatItem(const StatItem& from);
  
  inline StatItem& operator=(const StatItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatItem& default_instance();
  
  void Swap(StatItem* other);
  
  // implements Message ----------------------------------------------
  
  StatItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatItem& from);
  void MergeFrom(const StatItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string stat_key = 1;
  inline bool has_stat_key() const;
  inline void clear_stat_key();
  static const int kStatKeyFieldNumber = 1;
  inline const ::std::string& stat_key() const;
  inline void set_stat_key(const ::std::string& value);
  inline void set_stat_key(const char* value);
  inline void set_stat_key(const char* value, size_t size);
  inline ::std::string* mutable_stat_key();
  inline ::std::string* release_stat_key();
  
  // required int64 inc_value = 2;
  inline bool has_inc_value() const;
  inline void clear_inc_value();
  static const int kIncValueFieldNumber = 2;
  inline ::google::protobuf::int64 inc_value() const;
  inline void set_inc_value(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.StatItem)
 private:
  inline void set_has_stat_key();
  inline void clear_has_stat_key();
  inline void set_has_inc_value();
  inline void clear_has_inc_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* stat_key_;
  ::google::protobuf::int64 inc_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static StatItem* default_instance_;
};
// -------------------------------------------------------------------

class StatReport : public ::google::protobuf::Message {
 public:
  StatReport();
  virtual ~StatReport();
  
  StatReport(const StatReport& from);
  
  inline StatReport& operator=(const StatReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatReport& default_instance();
  
  void Swap(StatReport* other);
  
  // implements Message ----------------------------------------------
  
  StatReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatReport& from);
  void MergeFrom(const StatReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.ipc.StatItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::lbs::da::openservice::ipc::StatItem& items(int index) const;
  inline ::lbs::da::openservice::ipc::StatItem* mutable_items(int index);
  inline ::lbs::da::openservice::ipc::StatItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::StatItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::StatItem >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.StatReport)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::StatItem > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static StatReport* default_instance_;
};
// -------------------------------------------------------------------

class ProcessorUpgrade : public ::google::protobuf::Message {
 public:
  ProcessorUpgrade();
  virtual ~ProcessorUpgrade();
  
  ProcessorUpgrade(const ProcessorUpgrade& from);
  
  inline ProcessorUpgrade& operator=(const ProcessorUpgrade& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorUpgrade& default_instance();
  
  void Swap(ProcessorUpgrade* other);
  
  // implements Message ----------------------------------------------
  
  ProcessorUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessorUpgrade& from);
  void MergeFrom(const ProcessorUpgrade& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string old_processor = 1;
  inline bool has_old_processor() const;
  inline void clear_old_processor();
  static const int kOldProcessorFieldNumber = 1;
  inline const ::std::string& old_processor() const;
  inline void set_old_processor(const ::std::string& value);
  inline void set_old_processor(const char* value);
  inline void set_old_processor(const char* value, size_t size);
  inline ::std::string* mutable_old_processor();
  inline ::std::string* release_old_processor();
  
  // required string new_processor = 2;
  inline bool has_new_processor() const;
  inline void clear_new_processor();
  static const int kNewProcessorFieldNumber = 2;
  inline const ::std::string& new_processor() const;
  inline void set_new_processor(const ::std::string& value);
  inline void set_new_processor(const char* value);
  inline void set_new_processor(const char* value, size_t size);
  inline ::std::string* mutable_new_processor();
  inline ::std::string* release_new_processor();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.ProcessorUpgrade)
 private:
  inline void set_has_old_processor();
  inline void clear_has_old_processor();
  inline void set_has_new_processor();
  inline void clear_has_new_processor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* old_processor_;
  ::std::string* new_processor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static ProcessorUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class ChangeLogLevel : public ::google::protobuf::Message {
 public:
  ChangeLogLevel();
  virtual ~ChangeLogLevel();
  
  ChangeLogLevel(const ChangeLogLevel& from);
  
  inline ChangeLogLevel& operator=(const ChangeLogLevel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeLogLevel& default_instance();
  
  void Swap(ChangeLogLevel* other);
  
  // implements Message ----------------------------------------------
  
  ChangeLogLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeLogLevel& from);
  void MergeFrom(const ChangeLogLevel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ipc.ChangeLogLevel)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 level_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ipc_2eproto();
  friend void protobuf_AssignDesc_ipc_2eproto();
  friend void protobuf_ShutdownFile_ipc_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeLogLevel* default_instance_;
};
// ===================================================================


// ===================================================================

// ProcessorConnectRequest

// required string from_processor = 1;
inline bool ProcessorConnectRequest::has_from_processor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorConnectRequest::set_has_from_processor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorConnectRequest::clear_has_from_processor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorConnectRequest::clear_from_processor() {
  if (from_processor_ != &::google::protobuf::internal::kEmptyString) {
    from_processor_->clear();
  }
  clear_has_from_processor();
}
inline const ::std::string& ProcessorConnectRequest::from_processor() const {
  return *from_processor_;
}
inline void ProcessorConnectRequest::set_from_processor(const ::std::string& value) {
  set_has_from_processor();
  if (from_processor_ == &::google::protobuf::internal::kEmptyString) {
    from_processor_ = new ::std::string;
  }
  from_processor_->assign(value);
}
inline void ProcessorConnectRequest::set_from_processor(const char* value) {
  set_has_from_processor();
  if (from_processor_ == &::google::protobuf::internal::kEmptyString) {
    from_processor_ = new ::std::string;
  }
  from_processor_->assign(value);
}
inline void ProcessorConnectRequest::set_from_processor(const char* value, size_t size) {
  set_has_from_processor();
  if (from_processor_ == &::google::protobuf::internal::kEmptyString) {
    from_processor_ = new ::std::string;
  }
  from_processor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorConnectRequest::mutable_from_processor() {
  set_has_from_processor();
  if (from_processor_ == &::google::protobuf::internal::kEmptyString) {
    from_processor_ = new ::std::string;
  }
  return from_processor_;
}
inline ::std::string* ProcessorConnectRequest::release_from_processor() {
  clear_has_from_processor();
  if (from_processor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_processor_;
    from_processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 from_idx = 2;
inline bool ProcessorConnectRequest::has_from_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorConnectRequest::set_has_from_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorConnectRequest::clear_has_from_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorConnectRequest::clear_from_idx() {
  from_idx_ = 0;
  clear_has_from_idx();
}
inline ::google::protobuf::int32 ProcessorConnectRequest::from_idx() const {
  return from_idx_;
}
inline void ProcessorConnectRequest::set_from_idx(::google::protobuf::int32 value) {
  set_has_from_idx();
  from_idx_ = value;
}

// -------------------------------------------------------------------

// HeartBeatNotify

// -------------------------------------------------------------------

// RedisRequest

// required string source = 1;
inline bool RedisRequest::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedisRequest::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedisRequest::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedisRequest::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& RedisRequest::source() const {
  return *source_;
}
inline void RedisRequest::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void RedisRequest::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void RedisRequest::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisRequest::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* RedisRequest::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes shardkey = 2;
inline bool RedisRequest::has_shardkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedisRequest::set_has_shardkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedisRequest::clear_has_shardkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedisRequest::clear_shardkey() {
  if (shardkey_ != &::google::protobuf::internal::kEmptyString) {
    shardkey_->clear();
  }
  clear_has_shardkey();
}
inline const ::std::string& RedisRequest::shardkey() const {
  return *shardkey_;
}
inline void RedisRequest::set_shardkey(const ::std::string& value) {
  set_has_shardkey();
  if (shardkey_ == &::google::protobuf::internal::kEmptyString) {
    shardkey_ = new ::std::string;
  }
  shardkey_->assign(value);
}
inline void RedisRequest::set_shardkey(const char* value) {
  set_has_shardkey();
  if (shardkey_ == &::google::protobuf::internal::kEmptyString) {
    shardkey_ = new ::std::string;
  }
  shardkey_->assign(value);
}
inline void RedisRequest::set_shardkey(const void* value, size_t size) {
  set_has_shardkey();
  if (shardkey_ == &::google::protobuf::internal::kEmptyString) {
    shardkey_ = new ::std::string;
  }
  shardkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisRequest::mutable_shardkey() {
  set_has_shardkey();
  if (shardkey_ == &::google::protobuf::internal::kEmptyString) {
    shardkey_ = new ::std::string;
  }
  return shardkey_;
}
inline ::std::string* RedisRequest::release_shardkey() {
  clear_has_shardkey();
  if (shardkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shardkey_;
    shardkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes args = 3;
inline int RedisRequest::args_size() const {
  return args_.size();
}
inline void RedisRequest::clear_args() {
  args_.Clear();
}
inline const ::std::string& RedisRequest::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* RedisRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void RedisRequest::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void RedisRequest::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void RedisRequest::set_args(int index, const void* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisRequest::add_args() {
  return args_.Add();
}
inline void RedisRequest::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void RedisRequest::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void RedisRequest::add_args(const void* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RedisRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RedisRequest::mutable_args() {
  return &args_;
}

// required bool readonly = 4;
inline bool RedisRequest::has_readonly() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedisRequest::set_has_readonly() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedisRequest::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedisRequest::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool RedisRequest::readonly() const {
  return readonly_;
}
inline void RedisRequest::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
}

// -------------------------------------------------------------------

// RedisResponse

// required int32 type = 1;
inline bool RedisResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedisResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedisResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedisResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RedisResponse::type() const {
  return type_;
}
inline void RedisResponse::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int64 intv = 2;
inline bool RedisResponse::has_intv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedisResponse::set_has_intv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedisResponse::clear_has_intv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedisResponse::clear_intv() {
  intv_ = GOOGLE_LONGLONG(0);
  clear_has_intv();
}
inline ::google::protobuf::int64 RedisResponse::intv() const {
  return intv_;
}
inline void RedisResponse::set_intv(::google::protobuf::int64 value) {
  set_has_intv();
  intv_ = value;
}

// optional double floatv = 3;
inline bool RedisResponse::has_floatv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedisResponse::set_has_floatv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedisResponse::clear_has_floatv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedisResponse::clear_floatv() {
  floatv_ = 0;
  clear_has_floatv();
}
inline double RedisResponse::floatv() const {
  return floatv_;
}
inline void RedisResponse::set_floatv(double value) {
  set_has_floatv();
  floatv_ = value;
}

// optional bytes str = 4;
inline bool RedisResponse::has_str() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedisResponse::set_has_str() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedisResponse::clear_has_str() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedisResponse::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& RedisResponse::str() const {
  return *str_;
}
inline void RedisResponse::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void RedisResponse::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void RedisResponse::set_str(const void* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedisResponse::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* RedisResponse::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.ipc.RedisResponse elements = 5;
inline int RedisResponse::elements_size() const {
  return elements_.size();
}
inline void RedisResponse::clear_elements() {
  elements_.Clear();
}
inline const ::lbs::da::openservice::ipc::RedisResponse& RedisResponse::elements(int index) const {
  return elements_.Get(index);
}
inline ::lbs::da::openservice::ipc::RedisResponse* RedisResponse::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::lbs::da::openservice::ipc::RedisResponse* RedisResponse::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::RedisResponse >&
RedisResponse::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::RedisResponse >*
RedisResponse::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// StatItem

// required string stat_key = 1;
inline bool StatItem::has_stat_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatItem::set_has_stat_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatItem::clear_has_stat_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatItem::clear_stat_key() {
  if (stat_key_ != &::google::protobuf::internal::kEmptyString) {
    stat_key_->clear();
  }
  clear_has_stat_key();
}
inline const ::std::string& StatItem::stat_key() const {
  return *stat_key_;
}
inline void StatItem::set_stat_key(const ::std::string& value) {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  stat_key_->assign(value);
}
inline void StatItem::set_stat_key(const char* value) {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  stat_key_->assign(value);
}
inline void StatItem::set_stat_key(const char* value, size_t size) {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  stat_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatItem::mutable_stat_key() {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  return stat_key_;
}
inline ::std::string* StatItem::release_stat_key() {
  clear_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stat_key_;
    stat_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 inc_value = 2;
inline bool StatItem::has_inc_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatItem::set_has_inc_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatItem::clear_has_inc_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatItem::clear_inc_value() {
  inc_value_ = GOOGLE_LONGLONG(0);
  clear_has_inc_value();
}
inline ::google::protobuf::int64 StatItem::inc_value() const {
  return inc_value_;
}
inline void StatItem::set_inc_value(::google::protobuf::int64 value) {
  set_has_inc_value();
  inc_value_ = value;
}

// -------------------------------------------------------------------

// StatReport

// repeated .lbs.da.openservice.ipc.StatItem items = 1;
inline int StatReport::items_size() const {
  return items_.size();
}
inline void StatReport::clear_items() {
  items_.Clear();
}
inline const ::lbs::da::openservice::ipc::StatItem& StatReport::items(int index) const {
  return items_.Get(index);
}
inline ::lbs::da::openservice::ipc::StatItem* StatReport::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::lbs::da::openservice::ipc::StatItem* StatReport::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::StatItem >&
StatReport::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ipc::StatItem >*
StatReport::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ProcessorUpgrade

// required string old_processor = 1;
inline bool ProcessorUpgrade::has_old_processor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorUpgrade::set_has_old_processor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorUpgrade::clear_has_old_processor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorUpgrade::clear_old_processor() {
  if (old_processor_ != &::google::protobuf::internal::kEmptyString) {
    old_processor_->clear();
  }
  clear_has_old_processor();
}
inline const ::std::string& ProcessorUpgrade::old_processor() const {
  return *old_processor_;
}
inline void ProcessorUpgrade::set_old_processor(const ::std::string& value) {
  set_has_old_processor();
  if (old_processor_ == &::google::protobuf::internal::kEmptyString) {
    old_processor_ = new ::std::string;
  }
  old_processor_->assign(value);
}
inline void ProcessorUpgrade::set_old_processor(const char* value) {
  set_has_old_processor();
  if (old_processor_ == &::google::protobuf::internal::kEmptyString) {
    old_processor_ = new ::std::string;
  }
  old_processor_->assign(value);
}
inline void ProcessorUpgrade::set_old_processor(const char* value, size_t size) {
  set_has_old_processor();
  if (old_processor_ == &::google::protobuf::internal::kEmptyString) {
    old_processor_ = new ::std::string;
  }
  old_processor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorUpgrade::mutable_old_processor() {
  set_has_old_processor();
  if (old_processor_ == &::google::protobuf::internal::kEmptyString) {
    old_processor_ = new ::std::string;
  }
  return old_processor_;
}
inline ::std::string* ProcessorUpgrade::release_old_processor() {
  clear_has_old_processor();
  if (old_processor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_processor_;
    old_processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string new_processor = 2;
inline bool ProcessorUpgrade::has_new_processor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorUpgrade::set_has_new_processor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorUpgrade::clear_has_new_processor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorUpgrade::clear_new_processor() {
  if (new_processor_ != &::google::protobuf::internal::kEmptyString) {
    new_processor_->clear();
  }
  clear_has_new_processor();
}
inline const ::std::string& ProcessorUpgrade::new_processor() const {
  return *new_processor_;
}
inline void ProcessorUpgrade::set_new_processor(const ::std::string& value) {
  set_has_new_processor();
  if (new_processor_ == &::google::protobuf::internal::kEmptyString) {
    new_processor_ = new ::std::string;
  }
  new_processor_->assign(value);
}
inline void ProcessorUpgrade::set_new_processor(const char* value) {
  set_has_new_processor();
  if (new_processor_ == &::google::protobuf::internal::kEmptyString) {
    new_processor_ = new ::std::string;
  }
  new_processor_->assign(value);
}
inline void ProcessorUpgrade::set_new_processor(const char* value, size_t size) {
  set_has_new_processor();
  if (new_processor_ == &::google::protobuf::internal::kEmptyString) {
    new_processor_ = new ::std::string;
  }
  new_processor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorUpgrade::mutable_new_processor() {
  set_has_new_processor();
  if (new_processor_ == &::google::protobuf::internal::kEmptyString) {
    new_processor_ = new ::std::string;
  }
  return new_processor_;
}
inline ::std::string* ProcessorUpgrade::release_new_processor() {
  clear_has_new_processor();
  if (new_processor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_processor_;
    new_processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChangeLogLevel

// required uint32 level = 1;
inline bool ChangeLogLevel::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeLogLevel::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeLogLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeLogLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 ChangeLogLevel::level() const {
  return level_;
}
inline void ChangeLogLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ipc
}  // namespace openservice
}  // namespace da
}  // namespace lbs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ipc_2eproto__INCLUDED
