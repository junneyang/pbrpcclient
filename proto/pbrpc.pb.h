// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pbrpc.proto

#ifndef PROTOBUF_pbrpc_2eproto__INCLUDED
#define PROTOBUF_pbrpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace lbs {
namespace da {
namespace openservice {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pbrpc_2eproto();
void protobuf_AssignDesc_pbrpc_2eproto();
void protobuf_ShutdownFile_pbrpc_2eproto();

class RequestHeader;
class Arg;
class UserPreferenceTags;
class UserPreference;
class GetUserPreferenceRequest;
class GetUserPreferenceResponse;
class RegularStayPoint;
class GetRegularStayPointRequest;
class GetRegularStayPointResponse;
class Item;
class ItemBytes;
class GetItemsByItemRequest;
class GetItemsByItemResponse;
class GetBNItemsRequest;
class GetBNItemsResponse;
class GetLatestUserTrajRequest;
class GetLatestUserTrajResponse;
class StatElement;
class StatReportRequest;
class StatReportResponse;
class DayRoute;
class DynamicTripPlanRequest;
class DynamicTripPlanResponse;
class DayRouteInfo;
class LvTripPlanRequest;
class LvTripPlanResponse;
class WifiFinger;
class PlaceSemanticRequest;
class PoiProbability;
class PlaceSemanticResponse;
class NuomiUserPreferenceRequest;
class ScoreInfo;
class FeatureInfo;
class StrInfo;
class StrFeatureInfo;
class ItemUpInfo;
class NuomiUserPreferenceResponse;
class GetAOIRequest;
class GetAOIResponse;
class GetNearPoiRequest;
class PoiInfo;
class GetNearPoiResponse;

enum UserPreferenceSourceType {
  MAP_CATEGORY = 0,
  MAP_PRICE = 1,
  MAP_BRAND = 2,
  TUANGOU_CATEGORY = 10,
  TUANGOU_PRICE = 11,
  TUANGOU_BRAND = 12
};
bool UserPreferenceSourceType_IsValid(int value);
const UserPreferenceSourceType UserPreferenceSourceType_MIN = MAP_CATEGORY;
const UserPreferenceSourceType UserPreferenceSourceType_MAX = TUANGOU_BRAND;
const int UserPreferenceSourceType_ARRAYSIZE = UserPreferenceSourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserPreferenceSourceType_descriptor();
inline const ::std::string& UserPreferenceSourceType_Name(UserPreferenceSourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserPreferenceSourceType_descriptor(), value);
}
inline bool UserPreferenceSourceType_Parse(
    const ::std::string& name, UserPreferenceSourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserPreferenceSourceType>(
    UserPreferenceSourceType_descriptor(), name, value);
}
enum UserTrajStatus {
  HOME_STATUS = 0,
  COMPANY_STATUS = 1,
  AREA_STATUS = 2,
  LOCAL_STATUS = 3,
  EWORK_STATUS = 4,
  ETRAVEL_STATUS = 5,
  EFAMILY_STATUS = 6,
  ELOW_STATUS = 7,
  EHIGH_STATUS = 8,
  ENEW_STATUS = 9,
  UNKNOW_STATUS = 100
};
bool UserTrajStatus_IsValid(int value);
const UserTrajStatus UserTrajStatus_MIN = HOME_STATUS;
const UserTrajStatus UserTrajStatus_MAX = UNKNOW_STATUS;
const int UserTrajStatus_ARRAYSIZE = UserTrajStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserTrajStatus_descriptor();
inline const ::std::string& UserTrajStatus_Name(UserTrajStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserTrajStatus_descriptor(), value);
}
inline bool UserTrajStatus_Parse(
    const ::std::string& name, UserTrajStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserTrajStatus>(
    UserTrajStatus_descriptor(), name, value);
}
enum RequestIdType {
  PASSPORT_ID = 1,
  BAIDU_ID = 2,
  CUID = 3,
  IMEI = 4
};
bool RequestIdType_IsValid(int value);
const RequestIdType RequestIdType_MIN = PASSPORT_ID;
const RequestIdType RequestIdType_MAX = IMEI;
const int RequestIdType_ARRAYSIZE = RequestIdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestIdType_descriptor();
inline const ::std::string& RequestIdType_Name(RequestIdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestIdType_descriptor(), value);
}
inline bool RequestIdType_Parse(
    const ::std::string& name, RequestIdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestIdType>(
    RequestIdType_descriptor(), name, value);
}
enum NuomiDataType {
  NUOMI_OFFLINE = 1,
  NUOMI_ONLINE = 2,
  NUOMI_ALL = 3,
  ITEM_OFFLINE = 4,
  NUOMI_ITEM_OFFLINE = 5,
  ALL_DATA = 100
};
bool NuomiDataType_IsValid(int value);
const NuomiDataType NuomiDataType_MIN = NUOMI_OFFLINE;
const NuomiDataType NuomiDataType_MAX = ALL_DATA;
const int NuomiDataType_ARRAYSIZE = NuomiDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NuomiDataType_descriptor();
inline const ::std::string& NuomiDataType_Name(NuomiDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NuomiDataType_descriptor(), value);
}
inline bool NuomiDataType_Parse(
    const ::std::string& name, NuomiDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NuomiDataType>(
    NuomiDataType_descriptor(), name, value);
}
enum NuomiUpResultType {
  BY_PASSPORTID = 1,
  BY_BAIDUID = 2,
  BY_CUID = 3,
  BY_IMEI = 4,
  NO_RESULT = 100,
  RESULTS_ERROR = 101,
  REQUEST_ERROR = 102
};
bool NuomiUpResultType_IsValid(int value);
const NuomiUpResultType NuomiUpResultType_MIN = BY_PASSPORTID;
const NuomiUpResultType NuomiUpResultType_MAX = REQUEST_ERROR;
const int NuomiUpResultType_ARRAYSIZE = NuomiUpResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NuomiUpResultType_descriptor();
inline const ::std::string& NuomiUpResultType_Name(NuomiUpResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NuomiUpResultType_descriptor(), value);
}
inline bool NuomiUpResultType_Parse(
    const ::std::string& name, NuomiUpResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NuomiUpResultType>(
    NuomiUpResultType_descriptor(), name, value);
}
// ===================================================================

class RequestHeader : public ::google::protobuf::Message {
 public:
  RequestHeader();
  virtual ~RequestHeader();
  
  RequestHeader(const RequestHeader& from);
  
  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();
  
  void Swap(RequestHeader* other);
  
  // implements Message ----------------------------------------------
  
  RequestHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string servicekey = 1;
  inline bool has_servicekey() const;
  inline void clear_servicekey();
  static const int kServicekeyFieldNumber = 1;
  inline const ::std::string& servicekey() const;
  inline void set_servicekey(const ::std::string& value);
  inline void set_servicekey(const char* value);
  inline void set_servicekey(const char* value, size_t size);
  inline ::std::string* mutable_servicekey();
  inline ::std::string* release_servicekey();
  
  // optional string secretkey = 2;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretkeyFieldNumber = 2;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const char* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  
  // optional string subservice = 3;
  inline bool has_subservice() const;
  inline void clear_subservice();
  static const int kSubserviceFieldNumber = 3;
  inline const ::std::string& subservice() const;
  inline void set_subservice(const ::std::string& value);
  inline void set_subservice(const char* value);
  inline void set_subservice(const char* value, size_t size);
  inline ::std::string* mutable_subservice();
  inline ::std::string* release_subservice();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.RequestHeader)
 private:
  inline void set_has_servicekey();
  inline void clear_has_servicekey();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();
  inline void set_has_subservice();
  inline void clear_has_subservice();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* servicekey_;
  ::std::string* secretkey_;
  ::std::string* subservice_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static RequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class Arg : public ::google::protobuf::Message {
 public:
  Arg();
  virtual ~Arg();
  
  Arg(const Arg& from);
  
  inline Arg& operator=(const Arg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Arg& default_instance();
  
  void Swap(Arg* other);
  
  // implements Message ----------------------------------------------
  
  Arg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arg& from);
  void MergeFrom(const Arg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int64 int_v = 2;
  inline bool has_int_v() const;
  inline void clear_int_v();
  static const int kIntVFieldNumber = 2;
  inline ::google::protobuf::int64 int_v() const;
  inline void set_int_v(::google::protobuf::int64 value);
  
  // optional double double_v = 3;
  inline bool has_double_v() const;
  inline void clear_double_v();
  static const int kDoubleVFieldNumber = 3;
  inline double double_v() const;
  inline void set_double_v(double value);
  
  // optional string str_v = 4;
  inline bool has_str_v() const;
  inline void clear_str_v();
  static const int kStrVFieldNumber = 4;
  inline const ::std::string& str_v() const;
  inline void set_str_v(const ::std::string& value);
  inline void set_str_v(const char* value);
  inline void set_str_v(const char* value, size_t size);
  inline ::std::string* mutable_str_v();
  inline ::std::string* release_str_v();
  
  // repeated .lbs.da.openservice.Arg elements = 5;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 5;
  inline const ::lbs::da::openservice::Arg& elements(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_elements(int index);
  inline ::lbs::da::openservice::Arg* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_elements();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.Arg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_int_v();
  inline void clear_has_int_v();
  inline void set_has_double_v();
  inline void clear_has_double_v();
  inline void set_has_str_v();
  inline void clear_has_str_v();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int64 int_v_;
  double double_v_;
  ::std::string* str_v_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > elements_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static Arg* default_instance_;
};
// -------------------------------------------------------------------

class UserPreferenceTags : public ::google::protobuf::Message {
 public:
  UserPreferenceTags();
  virtual ~UserPreferenceTags();
  
  UserPreferenceTags(const UserPreferenceTags& from);
  
  inline UserPreferenceTags& operator=(const UserPreferenceTags& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPreferenceTags& default_instance();
  
  void Swap(UserPreferenceTags* other);
  
  // implements Message ----------------------------------------------
  
  UserPreferenceTags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPreferenceTags& from);
  void MergeFrom(const UserPreferenceTags& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.UserPreferenceTags)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static UserPreferenceTags* default_instance_;
};
// -------------------------------------------------------------------

class UserPreference : public ::google::protobuf::Message {
 public:
  UserPreference();
  virtual ~UserPreference();
  
  UserPreference(const UserPreference& from);
  
  inline UserPreference& operator=(const UserPreference& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPreference& default_instance();
  
  void Swap(UserPreference* other);
  
  // implements Message ----------------------------------------------
  
  UserPreference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPreference& from);
  void MergeFrom(const UserPreference& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);
  
  // optional string srcType = 4;
  inline bool has_srctype() const;
  inline void clear_srctype();
  static const int kSrcTypeFieldNumber = 4;
  inline const ::std::string& srctype() const;
  inline void set_srctype(const ::std::string& value);
  inline void set_srctype(const char* value);
  inline void set_srctype(const char* value, size_t size);
  inline ::std::string* mutable_srctype();
  inline ::std::string* release_srctype();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.UserPreference)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_srctype();
  inline void clear_has_srctype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* tag_;
  ::google::protobuf::int32 level_;
  float value_;
  ::std::string* srctype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static UserPreference* default_instance_;
};
// -------------------------------------------------------------------

class GetUserPreferenceRequest : public ::google::protobuf::Message {
 public:
  GetUserPreferenceRequest();
  virtual ~GetUserPreferenceRequest();
  
  GetUserPreferenceRequest(const GetUserPreferenceRequest& from);
  
  inline GetUserPreferenceRequest& operator=(const GetUserPreferenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserPreferenceRequest& default_instance();
  
  void Swap(GetUserPreferenceRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetUserPreferenceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserPreferenceRequest& from);
  void MergeFrom(const GetUserPreferenceRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // required string cuid = 2;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 2;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // repeated string srcType = 3;
  inline int srctype_size() const;
  inline void clear_srctype();
  static const int kSrcTypeFieldNumber = 3;
  inline const ::std::string& srctype(int index) const;
  inline ::std::string* mutable_srctype(int index);
  inline void set_srctype(int index, const ::std::string& value);
  inline void set_srctype(int index, const char* value);
  inline void set_srctype(int index, const char* value, size_t size);
  inline ::std::string* add_srctype();
  inline void add_srctype(const ::std::string& value);
  inline void add_srctype(const char* value);
  inline void add_srctype(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& srctype() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_srctype();
  
  // repeated string include_tag = 4;
  inline int include_tag_size() const;
  inline void clear_include_tag();
  static const int kIncludeTagFieldNumber = 4;
  inline const ::std::string& include_tag(int index) const;
  inline ::std::string* mutable_include_tag(int index);
  inline void set_include_tag(int index, const ::std::string& value);
  inline void set_include_tag(int index, const char* value);
  inline void set_include_tag(int index, const char* value, size_t size);
  inline ::std::string* add_include_tag();
  inline void add_include_tag(const ::std::string& value);
  inline void add_include_tag(const char* value);
  inline void add_include_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& include_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_include_tag();
  
  // repeated string exclude_tag = 5;
  inline int exclude_tag_size() const;
  inline void clear_exclude_tag();
  static const int kExcludeTagFieldNumber = 5;
  inline const ::std::string& exclude_tag(int index) const;
  inline ::std::string* mutable_exclude_tag(int index);
  inline void set_exclude_tag(int index, const ::std::string& value);
  inline void set_exclude_tag(int index, const char* value);
  inline void set_exclude_tag(int index, const char* value, size_t size);
  inline ::std::string* add_exclude_tag();
  inline void add_exclude_tag(const ::std::string& value);
  inline void add_exclude_tag(const char* value);
  inline void add_exclude_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exclude_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exclude_tag();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetUserPreferenceRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* cuid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> srctype_;
  ::google::protobuf::RepeatedPtrField< ::std::string> include_tag_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exclude_tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetUserPreferenceRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserPreferenceResponse : public ::google::protobuf::Message {
 public:
  GetUserPreferenceResponse();
  virtual ~GetUserPreferenceResponse();
  
  GetUserPreferenceResponse(const GetUserPreferenceResponse& from);
  
  inline GetUserPreferenceResponse& operator=(const GetUserPreferenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserPreferenceResponse& default_instance();
  
  void Swap(GetUserPreferenceResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetUserPreferenceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserPreferenceResponse& from);
  void MergeFrom(const GetUserPreferenceResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.UserPreference values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::lbs::da::openservice::UserPreference& values(int index) const;
  inline ::lbs::da::openservice::UserPreference* mutable_values(int index);
  inline ::lbs::da::openservice::UserPreference* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::UserPreference >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::UserPreference >*
      mutable_values();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetUserPreferenceResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::UserPreference > values_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetUserPreferenceResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegularStayPoint : public ::google::protobuf::Message {
 public:
  RegularStayPoint();
  virtual ~RegularStayPoint();
  
  RegularStayPoint(const RegularStayPoint& from);
  
  inline RegularStayPoint& operator=(const RegularStayPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegularStayPoint& default_instance();
  
  void Swap(RegularStayPoint* other);
  
  // implements Message ----------------------------------------------
  
  RegularStayPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegularStayPoint& from);
  void MergeFrom(const RegularStayPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.UserTrajStatus type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline lbs::da::openservice::UserTrajStatus type() const;
  inline void set_type(lbs::da::openservice::UserTrajStatus value);
  
  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // required double latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // optional double radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline double radius() const;
  inline void set_radius(double value);
  
  // optional int32 areaid = 5;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaidFieldNumber = 5;
  inline ::google::protobuf::int32 areaid() const;
  inline void set_areaid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.RegularStayPoint)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_areaid();
  inline void clear_has_areaid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double longitude_;
  double latitude_;
  int type_;
  ::google::protobuf::int32 areaid_;
  double radius_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static RegularStayPoint* default_instance_;
};
// -------------------------------------------------------------------

class GetRegularStayPointRequest : public ::google::protobuf::Message {
 public:
  GetRegularStayPointRequest();
  virtual ~GetRegularStayPointRequest();
  
  GetRegularStayPointRequest(const GetRegularStayPointRequest& from);
  
  inline GetRegularStayPointRequest& operator=(const GetRegularStayPointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRegularStayPointRequest& default_instance();
  
  void Swap(GetRegularStayPointRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetRegularStayPointRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRegularStayPointRequest& from);
  void MergeFrom(const GetRegularStayPointRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // required string cuid = 2;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 2;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // repeated .lbs.da.openservice.UserTrajStatus type = 3;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline lbs::da::openservice::UserTrajStatus type(int index) const;
  inline void set_type(int index, lbs::da::openservice::UserTrajStatus value);
  inline void add_type(lbs::da::openservice::UserTrajStatus value);
  inline const ::google::protobuf::RepeatedField<int>& type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_type();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetRegularStayPointRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* cuid_;
  ::google::protobuf::RepeatedField<int> type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetRegularStayPointRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetRegularStayPointResponse : public ::google::protobuf::Message {
 public:
  GetRegularStayPointResponse();
  virtual ~GetRegularStayPointResponse();
  
  GetRegularStayPointResponse(const GetRegularStayPointResponse& from);
  
  inline GetRegularStayPointResponse& operator=(const GetRegularStayPointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRegularStayPointResponse& default_instance();
  
  void Swap(GetRegularStayPointResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetRegularStayPointResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRegularStayPointResponse& from);
  void MergeFrom(const GetRegularStayPointResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.RegularStayPoint value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::lbs::da::openservice::RegularStayPoint& value(int index) const;
  inline ::lbs::da::openservice::RegularStayPoint* mutable_value(int index);
  inline ::lbs::da::openservice::RegularStayPoint* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegularStayPoint >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegularStayPoint >*
      mutable_value();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetRegularStayPointResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegularStayPoint > value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetRegularStayPointResponse* default_instance_;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();
  
  Item(const Item& from);
  
  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();
  
  void Swap(Item* other);
  
  // implements Message ----------------------------------------------
  
  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // repeated double value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();
  
  // repeated string str_value = 3;
  inline int str_value_size() const;
  inline void clear_str_value();
  static const int kStrValueFieldNumber = 3;
  inline const ::std::string& str_value(int index) const;
  inline ::std::string* mutable_str_value(int index);
  inline void set_str_value(int index, const ::std::string& value);
  inline void set_str_value(int index, const char* value);
  inline void set_str_value(int index, const char* value, size_t size);
  inline ::std::string* add_str_value();
  inline void add_str_value(const ::std::string& value);
  inline void add_str_value(const char* value);
  inline void add_str_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& str_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_str_value();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::RepeatedField< double > value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> str_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class ItemBytes : public ::google::protobuf::Message {
 public:
  ItemBytes();
  virtual ~ItemBytes();
  
  ItemBytes(const ItemBytes& from);
  
  inline ItemBytes& operator=(const ItemBytes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemBytes& default_instance();
  
  void Swap(ItemBytes* other);
  
  // implements Message ----------------------------------------------
  
  ItemBytes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemBytes& from);
  void MergeFrom(const ItemBytes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // repeated double value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();
  
  // repeated bytes str_value = 3;
  inline int str_value_size() const;
  inline void clear_str_value();
  static const int kStrValueFieldNumber = 3;
  inline const ::std::string& str_value(int index) const;
  inline ::std::string* mutable_str_value(int index);
  inline void set_str_value(int index, const ::std::string& value);
  inline void set_str_value(int index, const char* value);
  inline void set_str_value(int index, const void* value, size_t size);
  inline ::std::string* add_str_value();
  inline void add_str_value(const ::std::string& value);
  inline void add_str_value(const char* value);
  inline void add_str_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& str_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_str_value();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ItemBytes)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::RepeatedField< double > value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> str_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static ItemBytes* default_instance_;
};
// -------------------------------------------------------------------

class GetItemsByItemRequest : public ::google::protobuf::Message {
 public:
  GetItemsByItemRequest();
  virtual ~GetItemsByItemRequest();
  
  GetItemsByItemRequest(const GetItemsByItemRequest& from);
  
  inline GetItemsByItemRequest& operator=(const GetItemsByItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetItemsByItemRequest& default_instance();
  
  void Swap(GetItemsByItemRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetItemsByItemRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetItemsByItemRequest& from);
  void MergeFrom(const GetItemsByItemRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // optional string algorithmId = 2;
  inline bool has_algorithmid() const;
  inline void clear_algorithmid();
  static const int kAlgorithmIdFieldNumber = 2;
  inline const ::std::string& algorithmid() const;
  inline void set_algorithmid(const ::std::string& value);
  inline void set_algorithmid(const char* value);
  inline void set_algorithmid(const char* value, size_t size);
  inline ::std::string* mutable_algorithmid();
  inline ::std::string* release_algorithmid();
  
  // repeated string item_ids = 3;
  inline int item_ids_size() const;
  inline void clear_item_ids();
  static const int kItemIdsFieldNumber = 3;
  inline const ::std::string& item_ids(int index) const;
  inline ::std::string* mutable_item_ids(int index);
  inline void set_item_ids(int index, const ::std::string& value);
  inline void set_item_ids(int index, const char* value);
  inline void set_item_ids(int index, const char* value, size_t size);
  inline ::std::string* add_item_ids();
  inline void add_item_ids(const ::std::string& value);
  inline void add_item_ids(const char* value);
  inline void add_item_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item_ids();
  
  // optional string userid = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 4;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional string useridtype = 5;
  inline bool has_useridtype() const;
  inline void clear_useridtype();
  static const int kUseridtypeFieldNumber = 5;
  inline const ::std::string& useridtype() const;
  inline void set_useridtype(const ::std::string& value);
  inline void set_useridtype(const char* value);
  inline void set_useridtype(const char* value, size_t size);
  inline ::std::string* mutable_useridtype();
  inline ::std::string* release_useridtype();
  
  // optional int32 limit = 6;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 6;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // repeated .lbs.da.openservice.Arg args = 7;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 7;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetItemsByItemRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_algorithmid();
  inline void clear_has_algorithmid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_useridtype();
  inline void clear_has_useridtype();
  inline void set_has_limit();
  inline void clear_has_limit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* algorithmid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_ids_;
  ::std::string* userid_;
  ::std::string* useridtype_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  ::google::protobuf::int32 limit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetItemsByItemRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetItemsByItemResponse : public ::google::protobuf::Message {
 public:
  GetItemsByItemResponse();
  virtual ~GetItemsByItemResponse();
  
  GetItemsByItemResponse(const GetItemsByItemResponse& from);
  
  inline GetItemsByItemResponse& operator=(const GetItemsByItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetItemsByItemResponse& default_instance();
  
  void Swap(GetItemsByItemResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetItemsByItemResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetItemsByItemResponse& from);
  void MergeFrom(const GetItemsByItemResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.Item items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::lbs::da::openservice::Item& items(int index) const;
  inline ::lbs::da::openservice::Item* mutable_items(int index);
  inline ::lbs::da::openservice::Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Item >*
      mutable_items();
  
  // optional string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional string algorithmId = 3;
  inline bool has_algorithmid() const;
  inline void clear_algorithmid();
  static const int kAlgorithmIdFieldNumber = 3;
  inline const ::std::string& algorithmid() const;
  inline void set_algorithmid(const ::std::string& value);
  inline void set_algorithmid(const char* value);
  inline void set_algorithmid(const char* value, size_t size);
  inline ::std::string* mutable_algorithmid();
  inline ::std::string* release_algorithmid();
  
  // optional string uniqId = 4;
  inline bool has_uniqid() const;
  inline void clear_uniqid();
  static const int kUniqIdFieldNumber = 4;
  inline const ::std::string& uniqid() const;
  inline void set_uniqid(const ::std::string& value);
  inline void set_uniqid(const char* value);
  inline void set_uniqid(const char* value, size_t size);
  inline ::std::string* mutable_uniqid();
  inline ::std::string* release_uniqid();
  
  // optional string bid = 5;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 5;
  inline const ::std::string& bid() const;
  inline void set_bid(const ::std::string& value);
  inline void set_bid(const char* value);
  inline void set_bid(const char* value, size_t size);
  inline ::std::string* mutable_bid();
  inline ::std::string* release_bid();
  
  // repeated .lbs.da.openservice.Arg args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetItemsByItemResponse)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_algorithmid();
  inline void clear_has_algorithmid();
  inline void set_has_uniqid();
  inline void clear_has_uniqid();
  inline void set_has_bid();
  inline void clear_has_bid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Item > items_;
  ::std::string* userid_;
  ::std::string* algorithmid_;
  ::std::string* uniqid_;
  ::std::string* bid_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetItemsByItemResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetBNItemsRequest : public ::google::protobuf::Message {
 public:
  GetBNItemsRequest();
  virtual ~GetBNItemsRequest();
  
  GetBNItemsRequest(const GetBNItemsRequest& from);
  
  inline GetBNItemsRequest& operator=(const GetBNItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBNItemsRequest& default_instance();
  
  void Swap(GetBNItemsRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetBNItemsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBNItemsRequest& from);
  void MergeFrom(const GetBNItemsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // optional bytes algorithmId = 2;
  inline bool has_algorithmid() const;
  inline void clear_algorithmid();
  static const int kAlgorithmIdFieldNumber = 2;
  inline const ::std::string& algorithmid() const;
  inline void set_algorithmid(const ::std::string& value);
  inline void set_algorithmid(const char* value);
  inline void set_algorithmid(const void* value, size_t size);
  inline ::std::string* mutable_algorithmid();
  inline ::std::string* release_algorithmid();
  
  // optional int32 limit = 3;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 3;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 source = 4;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 4;
  inline ::google::protobuf::int32 source() const;
  inline void set_source(::google::protobuf::int32 value);
  
  // optional bytes userid = 5;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 5;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const void* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional bytes cuid = 6;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 6;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const void* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional bytes baidu_id = 7;
  inline bool has_baidu_id() const;
  inline void clear_baidu_id();
  static const int kBaiduIdFieldNumber = 7;
  inline const ::std::string& baidu_id() const;
  inline void set_baidu_id(const ::std::string& value);
  inline void set_baidu_id(const char* value);
  inline void set_baidu_id(const void* value, size_t size);
  inline ::std::string* mutable_baidu_id();
  inline ::std::string* release_baidu_id();
  
  // optional bytes nm_key = 8;
  inline bool has_nm_key() const;
  inline void clear_nm_key();
  static const int kNmKeyFieldNumber = 8;
  inline const ::std::string& nm_key() const;
  inline void set_nm_key(const ::std::string& value);
  inline void set_nm_key(const char* value);
  inline void set_nm_key(const void* value, size_t size);
  inline ::std::string* mutable_nm_key();
  inline ::std::string* release_nm_key();
  
  // optional bytes useridtype = 9;
  inline bool has_useridtype() const;
  inline void clear_useridtype();
  static const int kUseridtypeFieldNumber = 9;
  inline const ::std::string& useridtype() const;
  inline void set_useridtype(const ::std::string& value);
  inline void set_useridtype(const char* value);
  inline void set_useridtype(const void* value, size_t size);
  inline ::std::string* mutable_useridtype();
  inline ::std::string* release_useridtype();
  
  // optional bytes coor_sys = 10;
  inline bool has_coor_sys() const;
  inline void clear_coor_sys();
  static const int kCoorSysFieldNumber = 10;
  inline const ::std::string& coor_sys() const;
  inline void set_coor_sys(const ::std::string& value);
  inline void set_coor_sys(const char* value);
  inline void set_coor_sys(const void* value, size_t size);
  inline ::std::string* mutable_coor_sys();
  inline ::std::string* release_coor_sys();
  
  // optional float x = 11;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 11;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 12;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 12;
  inline float y() const;
  inline void set_y(float value);
  
  // optional int64 area_id = 13;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 13;
  inline ::google::protobuf::int64 area_id() const;
  inline void set_area_id(::google::protobuf::int64 value);
  
  // optional bytes query = 14;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 14;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const void* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  
  // repeated int64 vec_catg = 15;
  inline int vec_catg_size() const;
  inline void clear_vec_catg();
  static const int kVecCatgFieldNumber = 15;
  inline ::google::protobuf::int64 vec_catg(int index) const;
  inline void set_vec_catg(int index, ::google::protobuf::int64 value);
  inline void add_vec_catg(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      vec_catg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_vec_catg();
  
  // repeated int64 vec_subcatg = 16;
  inline int vec_subcatg_size() const;
  inline void clear_vec_subcatg();
  static const int kVecSubcatgFieldNumber = 16;
  inline ::google::protobuf::int64 vec_subcatg(int index) const;
  inline void set_vec_subcatg(int index, ::google::protobuf::int64 value);
  inline void add_vec_subcatg(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      vec_subcatg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_vec_subcatg();
  
  // repeated int64 vec_thdcatg = 17;
  inline int vec_thdcatg_size() const;
  inline void clear_vec_thdcatg();
  static const int kVecThdcatgFieldNumber = 17;
  inline ::google::protobuf::int64 vec_thdcatg(int index) const;
  inline void set_vec_thdcatg(int index, ::google::protobuf::int64 value);
  inline void add_vec_thdcatg(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      vec_thdcatg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_vec_thdcatg();
  
  // repeated int64 vec_shop_dist = 18;
  inline int vec_shop_dist_size() const;
  inline void clear_vec_shop_dist();
  static const int kVecShopDistFieldNumber = 18;
  inline ::google::protobuf::int64 vec_shop_dist(int index) const;
  inline void set_vec_shop_dist(int index, ::google::protobuf::int64 value);
  inline void add_vec_shop_dist(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      vec_shop_dist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_vec_shop_dist();
  
  // repeated int64 vec_shop_range = 19;
  inline int vec_shop_range_size() const;
  inline void clear_vec_shop_range();
  static const int kVecShopRangeFieldNumber = 19;
  inline ::google::protobuf::int64 vec_shop_range(int index) const;
  inline void set_vec_shop_range(int index, ::google::protobuf::int64 value);
  inline void add_vec_shop_range(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      vec_shop_range() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_vec_shop_range();
  
  // repeated bytes item_ids = 20;
  inline int item_ids_size() const;
  inline void clear_item_ids();
  static const int kItemIdsFieldNumber = 20;
  inline const ::std::string& item_ids(int index) const;
  inline ::std::string* mutable_item_ids(int index);
  inline void set_item_ids(int index, const ::std::string& value);
  inline void set_item_ids(int index, const char* value);
  inline void set_item_ids(int index, const void* value, size_t size);
  inline ::std::string* add_item_ids();
  inline void add_item_ids(const ::std::string& value);
  inline void add_item_ids(const char* value);
  inline void add_item_ids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item_ids();
  
  // optional int32 item_id_format = 21;
  inline bool has_item_id_format() const;
  inline void clear_item_id_format();
  static const int kItemIdFormatFieldNumber = 21;
  inline ::google::protobuf::int32 item_id_format() const;
  inline void set_item_id_format(::google::protobuf::int32 value);
  
  // repeated int64 qrw_vec_brand_id = 22;
  inline int qrw_vec_brand_id_size() const;
  inline void clear_qrw_vec_brand_id();
  static const int kQrwVecBrandIdFieldNumber = 22;
  inline ::google::protobuf::int64 qrw_vec_brand_id(int index) const;
  inline void set_qrw_vec_brand_id(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_brand_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_brand_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_brand_id();
  
  // repeated int64 qrw_vec_thdcatg = 23;
  inline int qrw_vec_thdcatg_size() const;
  inline void clear_qrw_vec_thdcatg();
  static const int kQrwVecThdcatgFieldNumber = 23;
  inline ::google::protobuf::int64 qrw_vec_thdcatg(int index) const;
  inline void set_qrw_vec_thdcatg(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_thdcatg(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_thdcatg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_thdcatg();
  
  // repeated int64 qrw_vec_subcatg = 24;
  inline int qrw_vec_subcatg_size() const;
  inline void clear_qrw_vec_subcatg();
  static const int kQrwVecSubcatgFieldNumber = 24;
  inline ::google::protobuf::int64 qrw_vec_subcatg(int index) const;
  inline void set_qrw_vec_subcatg(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_subcatg(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_subcatg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_subcatg();
  
  // repeated int64 qrw_vec_catg = 25;
  inline int qrw_vec_catg_size() const;
  inline void clear_qrw_vec_catg();
  static const int kQrwVecCatgFieldNumber = 25;
  inline ::google::protobuf::int64 qrw_vec_catg(int index) const;
  inline void set_qrw_vec_catg(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_catg(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_catg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_catg();
  
  // repeated int64 qrw_vec_shop_city = 26;
  inline int qrw_vec_shop_city_size() const;
  inline void clear_qrw_vec_shop_city();
  static const int kQrwVecShopCityFieldNumber = 26;
  inline ::google::protobuf::int64 qrw_vec_shop_city(int index) const;
  inline void set_qrw_vec_shop_city(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_shop_city(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_shop_city() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_shop_city();
  
  // repeated int64 qrw_vec_shop_dist = 27;
  inline int qrw_vec_shop_dist_size() const;
  inline void clear_qrw_vec_shop_dist();
  static const int kQrwVecShopDistFieldNumber = 27;
  inline ::google::protobuf::int64 qrw_vec_shop_dist(int index) const;
  inline void set_qrw_vec_shop_dist(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_shop_dist(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_shop_dist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_shop_dist();
  
  // repeated int64 qrw_vec_shop_range = 28;
  inline int qrw_vec_shop_range_size() const;
  inline void clear_qrw_vec_shop_range();
  static const int kQrwVecShopRangeFieldNumber = 28;
  inline ::google::protobuf::int64 qrw_vec_shop_range(int index) const;
  inline void set_qrw_vec_shop_range(int index, ::google::protobuf::int64 value);
  inline void add_qrw_vec_shop_range(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      qrw_vec_shop_range() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_qrw_vec_shop_range();
  
  // repeated .lbs.da.openservice.Arg args = 29;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 29;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetBNItemsRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_algorithmid();
  inline void clear_has_algorithmid();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_baidu_id();
  inline void clear_has_baidu_id();
  inline void set_has_nm_key();
  inline void clear_has_nm_key();
  inline void set_has_useridtype();
  inline void clear_has_useridtype();
  inline void set_has_coor_sys();
  inline void clear_has_coor_sys();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_item_id_format();
  inline void clear_has_item_id_format();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* algorithmid_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 source_;
  ::std::string* userid_;
  ::std::string* cuid_;
  ::std::string* baidu_id_;
  ::std::string* nm_key_;
  ::std::string* useridtype_;
  ::std::string* coor_sys_;
  float x_;
  float y_;
  ::google::protobuf::int64 area_id_;
  ::std::string* query_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > vec_catg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > vec_subcatg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > vec_thdcatg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > vec_shop_dist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > vec_shop_range_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_brand_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_thdcatg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_subcatg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_catg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_shop_city_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_shop_dist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > qrw_vec_shop_range_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  ::google::protobuf::int32 item_id_format_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetBNItemsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetBNItemsResponse : public ::google::protobuf::Message {
 public:
  GetBNItemsResponse();
  virtual ~GetBNItemsResponse();
  
  GetBNItemsResponse(const GetBNItemsResponse& from);
  
  inline GetBNItemsResponse& operator=(const GetBNItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBNItemsResponse& default_instance();
  
  void Swap(GetBNItemsResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetBNItemsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBNItemsResponse& from);
  void MergeFrom(const GetBNItemsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.ItemBytes items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::lbs::da::openservice::ItemBytes& items(int index) const;
  inline ::lbs::da::openservice::ItemBytes* mutable_items(int index);
  inline ::lbs::da::openservice::ItemBytes* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemBytes >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemBytes >*
      mutable_items();
  
  // optional bytes userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const void* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional bytes algorithmId = 3;
  inline bool has_algorithmid() const;
  inline void clear_algorithmid();
  static const int kAlgorithmIdFieldNumber = 3;
  inline const ::std::string& algorithmid() const;
  inline void set_algorithmid(const ::std::string& value);
  inline void set_algorithmid(const char* value);
  inline void set_algorithmid(const void* value, size_t size);
  inline ::std::string* mutable_algorithmid();
  inline ::std::string* release_algorithmid();
  
  // optional bytes uniqId = 4;
  inline bool has_uniqid() const;
  inline void clear_uniqid();
  static const int kUniqIdFieldNumber = 4;
  inline const ::std::string& uniqid() const;
  inline void set_uniqid(const ::std::string& value);
  inline void set_uniqid(const char* value);
  inline void set_uniqid(const void* value, size_t size);
  inline ::std::string* mutable_uniqid();
  inline ::std::string* release_uniqid();
  
  // optional bytes bid = 5;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 5;
  inline const ::std::string& bid() const;
  inline void set_bid(const ::std::string& value);
  inline void set_bid(const char* value);
  inline void set_bid(const void* value, size_t size);
  inline ::std::string* mutable_bid();
  inline ::std::string* release_bid();
  
  // repeated .lbs.da.openservice.Arg args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetBNItemsResponse)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_algorithmid();
  inline void clear_has_algorithmid();
  inline void set_has_uniqid();
  inline void clear_has_uniqid();
  inline void set_has_bid();
  inline void clear_has_bid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemBytes > items_;
  ::std::string* userid_;
  ::std::string* algorithmid_;
  ::std::string* uniqid_;
  ::std::string* bid_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetBNItemsResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetLatestUserTrajRequest : public ::google::protobuf::Message {
 public:
  GetLatestUserTrajRequest();
  virtual ~GetLatestUserTrajRequest();
  
  GetLatestUserTrajRequest(const GetLatestUserTrajRequest& from);
  
  inline GetLatestUserTrajRequest& operator=(const GetLatestUserTrajRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLatestUserTrajRequest& default_instance();
  
  void Swap(GetLatestUserTrajRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetLatestUserTrajRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLatestUserTrajRequest& from);
  void MergeFrom(const GetLatestUserTrajRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // required string cuid = 2;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 2;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetLatestUserTrajRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* cuid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetLatestUserTrajRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetLatestUserTrajResponse : public ::google::protobuf::Message {
 public:
  GetLatestUserTrajResponse();
  virtual ~GetLatestUserTrajResponse();
  
  GetLatestUserTrajResponse(const GetLatestUserTrajResponse& from);
  
  inline GetLatestUserTrajResponse& operator=(const GetLatestUserTrajResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLatestUserTrajResponse& default_instance();
  
  void Swap(GetLatestUserTrajResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetLatestUserTrajResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLatestUserTrajResponse& from);
  void MergeFrom(const GetLatestUserTrajResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .lbs.da.openservice.UserTrajStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline lbs::da::openservice::UserTrajStatus status() const;
  inline void set_status(lbs::da::openservice::UserTrajStatus value);
  
  // optional bool is_sticked = 2;
  inline bool has_is_sticked() const;
  inline void clear_is_sticked();
  static const int kIsStickedFieldNumber = 2;
  inline bool is_sticked() const;
  inline void set_is_sticked(bool value);
  
  // optional double longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // optional double latitude = 4;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // optional int64 start_time = 5;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);
  
  // optional int64 update_time = 6;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 update_time() const;
  inline void set_update_time(::google::protobuf::int64 value);
  
  // optional int32 staytime = 7;
  inline bool has_staytime() const;
  inline void clear_staytime();
  static const int kStaytimeFieldNumber = 7;
  inline ::google::protobuf::int32 staytime() const;
  inline void set_staytime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetLatestUserTrajResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_sticked();
  inline void clear_has_is_sticked();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_staytime();
  inline void clear_has_staytime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int status_;
  bool is_sticked_;
  double longitude_;
  double latitude_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 update_time_;
  ::google::protobuf::int32 staytime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetLatestUserTrajResponse* default_instance_;
};
// -------------------------------------------------------------------

class StatElement : public ::google::protobuf::Message {
 public:
  StatElement();
  virtual ~StatElement();
  
  StatElement(const StatElement& from);
  
  inline StatElement& operator=(const StatElement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatElement& default_instance();
  
  void Swap(StatElement* other);
  
  // implements Message ----------------------------------------------
  
  StatElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatElement& from);
  void MergeFrom(const StatElement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string stat_key = 1;
  inline bool has_stat_key() const;
  inline void clear_stat_key();
  static const int kStatKeyFieldNumber = 1;
  inline const ::std::string& stat_key() const;
  inline void set_stat_key(const ::std::string& value);
  inline void set_stat_key(const char* value);
  inline void set_stat_key(const char* value, size_t size);
  inline ::std::string* mutable_stat_key();
  inline ::std::string* release_stat_key();
  
  // required int64 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.StatElement)
 private:
  inline void set_has_stat_key();
  inline void clear_has_stat_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* stat_key_;
  ::google::protobuf::int64 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static StatElement* default_instance_;
};
// -------------------------------------------------------------------

class StatReportRequest : public ::google::protobuf::Message {
 public:
  StatReportRequest();
  virtual ~StatReportRequest();
  
  StatReportRequest(const StatReportRequest& from);
  
  inline StatReportRequest& operator=(const StatReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatReportRequest& default_instance();
  
  void Swap(StatReportRequest* other);
  
  // implements Message ----------------------------------------------
  
  StatReportRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatReportRequest& from);
  void MergeFrom(const StatReportRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // repeated .lbs.da.openservice.StatElement items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::lbs::da::openservice::StatElement& items(int index) const;
  inline ::lbs::da::openservice::StatElement* mutable_items(int index);
  inline ::lbs::da::openservice::StatElement* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.StatReportRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static StatReportRequest* default_instance_;
};
// -------------------------------------------------------------------

class StatReportResponse : public ::google::protobuf::Message {
 public:
  StatReportResponse();
  virtual ~StatReportResponse();
  
  StatReportResponse(const StatReportResponse& from);
  
  inline StatReportResponse& operator=(const StatReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatReportResponse& default_instance();
  
  void Swap(StatReportResponse* other);
  
  // implements Message ----------------------------------------------
  
  StatReportResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatReportResponse& from);
  void MergeFrom(const StatReportResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.StatElement items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::lbs::da::openservice::StatElement& items(int index) const;
  inline ::lbs::da::openservice::StatElement* mutable_items(int index);
  inline ::lbs::da::openservice::StatElement* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.StatReportResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static StatReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class DayRoute : public ::google::protobuf::Message {
 public:
  DayRoute();
  virtual ~DayRoute();
  
  DayRoute(const DayRoute& from);
  
  inline DayRoute& operator=(const DayRoute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DayRoute& default_instance();
  
  void Swap(DayRoute* other);
  
  // implements Message ----------------------------------------------
  
  DayRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DayRoute& from);
  void MergeFrom(const DayRoute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string lv_id = 1;
  inline int lv_id_size() const;
  inline void clear_lv_id();
  static const int kLvIdFieldNumber = 1;
  inline const ::std::string& lv_id(int index) const;
  inline ::std::string* mutable_lv_id(int index);
  inline void set_lv_id(int index, const ::std::string& value);
  inline void set_lv_id(int index, const char* value);
  inline void set_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_lv_id();
  inline void add_lv_id(const ::std::string& value);
  inline void add_lv_id(const char* value);
  inline void add_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lv_id();
  
  // optional double scene_dura_time = 2;
  inline bool has_scene_dura_time() const;
  inline void clear_scene_dura_time();
  static const int kSceneDuraTimeFieldNumber = 2;
  inline double scene_dura_time() const;
  inline void set_scene_dura_time(double value);
  
  // repeated string cater = 3;
  inline int cater_size() const;
  inline void clear_cater();
  static const int kCaterFieldNumber = 3;
  inline const ::std::string& cater(int index) const;
  inline ::std::string* mutable_cater(int index);
  inline void set_cater(int index, const ::std::string& value);
  inline void set_cater(int index, const char* value);
  inline void set_cater(int index, const char* value, size_t size);
  inline ::std::string* add_cater();
  inline void add_cater(const ::std::string& value);
  inline void add_cater(const char* value);
  inline void add_cater(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cater() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cater();
  
  // repeated string hotel = 4;
  inline int hotel_size() const;
  inline void clear_hotel();
  static const int kHotelFieldNumber = 4;
  inline const ::std::string& hotel(int index) const;
  inline ::std::string* mutable_hotel(int index);
  inline void set_hotel(int index, const ::std::string& value);
  inline void set_hotel(int index, const char* value);
  inline void set_hotel(int index, const char* value, size_t size);
  inline ::std::string* add_hotel();
  inline void add_hotel(const ::std::string& value);
  inline void add_hotel(const char* value);
  inline void add_hotel(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hotel() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hotel();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.DayRoute)
 private:
  inline void set_has_scene_dura_time();
  inline void clear_has_scene_dura_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> lv_id_;
  double scene_dura_time_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cater_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hotel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static DayRoute* default_instance_;
};
// -------------------------------------------------------------------

class DynamicTripPlanRequest : public ::google::protobuf::Message {
 public:
  DynamicTripPlanRequest();
  virtual ~DynamicTripPlanRequest();
  
  DynamicTripPlanRequest(const DynamicTripPlanRequest& from);
  
  inline DynamicTripPlanRequest& operator=(const DynamicTripPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicTripPlanRequest& default_instance();
  
  void Swap(DynamicTripPlanRequest* other);
  
  // implements Message ----------------------------------------------
  
  DynamicTripPlanRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynamicTripPlanRequest& from);
  void MergeFrom(const DynamicTripPlanRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // repeated string lv_id = 2;
  inline int lv_id_size() const;
  inline void clear_lv_id();
  static const int kLvIdFieldNumber = 2;
  inline const ::std::string& lv_id(int index) const;
  inline ::std::string* mutable_lv_id(int index);
  inline void set_lv_id(int index, const ::std::string& value);
  inline void set_lv_id(int index, const char* value);
  inline void set_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_lv_id();
  inline void add_lv_id(const ::std::string& value);
  inline void add_lv_id(const char* value);
  inline void add_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lv_id();
  
  // optional string userid = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 3;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // repeated string cater = 4;
  inline int cater_size() const;
  inline void clear_cater();
  static const int kCaterFieldNumber = 4;
  inline const ::std::string& cater(int index) const;
  inline ::std::string* mutable_cater(int index);
  inline void set_cater(int index, const ::std::string& value);
  inline void set_cater(int index, const char* value);
  inline void set_cater(int index, const char* value, size_t size);
  inline ::std::string* add_cater();
  inline void add_cater(const ::std::string& value);
  inline void add_cater(const char* value);
  inline void add_cater(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cater() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cater();
  
  // repeated string hotel = 5;
  inline int hotel_size() const;
  inline void clear_hotel();
  static const int kHotelFieldNumber = 5;
  inline const ::std::string& hotel(int index) const;
  inline ::std::string* mutable_hotel(int index);
  inline void set_hotel(int index, const ::std::string& value);
  inline void set_hotel(int index, const char* value);
  inline void set_hotel(int index, const char* value, size_t size);
  inline ::std::string* add_hotel();
  inline void add_hotel(const ::std::string& value);
  inline void add_hotel(const char* value);
  inline void add_hotel(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hotel() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hotel();
  
  // repeated .lbs.da.openservice.Arg args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.DynamicTripPlanRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lv_id_;
  ::std::string* userid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cater_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hotel_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static DynamicTripPlanRequest* default_instance_;
};
// -------------------------------------------------------------------

class DynamicTripPlanResponse : public ::google::protobuf::Message {
 public:
  DynamicTripPlanResponse();
  virtual ~DynamicTripPlanResponse();
  
  DynamicTripPlanResponse(const DynamicTripPlanResponse& from);
  
  inline DynamicTripPlanResponse& operator=(const DynamicTripPlanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicTripPlanResponse& default_instance();
  
  void Swap(DynamicTripPlanResponse* other);
  
  // implements Message ----------------------------------------------
  
  DynamicTripPlanResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynamicTripPlanResponse& from);
  void MergeFrom(const DynamicTripPlanResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required int64 total_distance = 2;
  inline bool has_total_distance() const;
  inline void clear_total_distance();
  static const int kTotalDistanceFieldNumber = 2;
  inline ::google::protobuf::int64 total_distance() const;
  inline void set_total_distance(::google::protobuf::int64 value);
  
  // repeated string lv_id = 3;
  inline int lv_id_size() const;
  inline void clear_lv_id();
  static const int kLvIdFieldNumber = 3;
  inline const ::std::string& lv_id(int index) const;
  inline ::std::string* mutable_lv_id(int index);
  inline void set_lv_id(int index, const ::std::string& value);
  inline void set_lv_id(int index, const char* value);
  inline void set_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_lv_id();
  inline void add_lv_id(const ::std::string& value);
  inline void add_lv_id(const char* value);
  inline void add_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lv_id();
  
  // repeated .lbs.da.openservice.DayRoute dayroute = 4;
  inline int dayroute_size() const;
  inline void clear_dayroute();
  static const int kDayrouteFieldNumber = 4;
  inline const ::lbs::da::openservice::DayRoute& dayroute(int index) const;
  inline ::lbs::da::openservice::DayRoute* mutable_dayroute(int index);
  inline ::lbs::da::openservice::DayRoute* add_dayroute();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRoute >&
      dayroute() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRoute >*
      mutable_dayroute();
  
  // repeated string origin_lv_id = 5;
  inline int origin_lv_id_size() const;
  inline void clear_origin_lv_id();
  static const int kOriginLvIdFieldNumber = 5;
  inline const ::std::string& origin_lv_id(int index) const;
  inline ::std::string* mutable_origin_lv_id(int index);
  inline void set_origin_lv_id(int index, const ::std::string& value);
  inline void set_origin_lv_id(int index, const char* value);
  inline void set_origin_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_origin_lv_id();
  inline void add_origin_lv_id(const ::std::string& value);
  inline void add_origin_lv_id(const char* value);
  inline void add_origin_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& origin_lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_origin_lv_id();
  
  // optional string userid = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 6;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional string uniq_id = 7;
  inline bool has_uniq_id() const;
  inline void clear_uniq_id();
  static const int kUniqIdFieldNumber = 7;
  inline const ::std::string& uniq_id() const;
  inline void set_uniq_id(const ::std::string& value);
  inline void set_uniq_id(const char* value);
  inline void set_uniq_id(const char* value, size_t size);
  inline ::std::string* mutable_uniq_id();
  inline ::std::string* release_uniq_id();
  
  // repeated .lbs.da.openservice.Arg args = 8;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 8;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.DynamicTripPlanResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_total_distance();
  inline void clear_has_total_distance();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_uniq_id();
  inline void clear_has_uniq_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 total_distance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lv_id_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRoute > dayroute_;
  ::google::protobuf::RepeatedPtrField< ::std::string> origin_lv_id_;
  ::std::string* userid_;
  ::std::string* uniq_id_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static DynamicTripPlanResponse* default_instance_;
};
// -------------------------------------------------------------------

class DayRouteInfo : public ::google::protobuf::Message {
 public:
  DayRouteInfo();
  virtual ~DayRouteInfo();
  
  DayRouteInfo(const DayRouteInfo& from);
  
  inline DayRouteInfo& operator=(const DayRouteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DayRouteInfo& default_instance();
  
  void Swap(DayRouteInfo* other);
  
  // implements Message ----------------------------------------------
  
  DayRouteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DayRouteInfo& from);
  void MergeFrom(const DayRouteInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string lv_id = 1;
  inline int lv_id_size() const;
  inline void clear_lv_id();
  static const int kLvIdFieldNumber = 1;
  inline const ::std::string& lv_id(int index) const;
  inline ::std::string* mutable_lv_id(int index);
  inline void set_lv_id(int index, const ::std::string& value);
  inline void set_lv_id(int index, const char* value);
  inline void set_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_lv_id();
  inline void add_lv_id(const ::std::string& value);
  inline void add_lv_id(const char* value);
  inline void add_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lv_id();
  
  // optional double scene_dura_time = 2;
  inline bool has_scene_dura_time() const;
  inline void clear_scene_dura_time();
  static const int kSceneDuraTimeFieldNumber = 2;
  inline double scene_dura_time() const;
  inline void set_scene_dura_time(double value);
  
  // repeated string cater = 3;
  inline int cater_size() const;
  inline void clear_cater();
  static const int kCaterFieldNumber = 3;
  inline const ::std::string& cater(int index) const;
  inline ::std::string* mutable_cater(int index);
  inline void set_cater(int index, const ::std::string& value);
  inline void set_cater(int index, const char* value);
  inline void set_cater(int index, const char* value, size_t size);
  inline ::std::string* add_cater();
  inline void add_cater(const ::std::string& value);
  inline void add_cater(const char* value);
  inline void add_cater(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cater() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cater();
  
  // repeated string hotel = 4;
  inline int hotel_size() const;
  inline void clear_hotel();
  static const int kHotelFieldNumber = 4;
  inline const ::std::string& hotel(int index) const;
  inline ::std::string* mutable_hotel(int index);
  inline void set_hotel(int index, const ::std::string& value);
  inline void set_hotel(int index, const char* value);
  inline void set_hotel(int index, const char* value, size_t size);
  inline ::std::string* add_hotel();
  inline void add_hotel(const ::std::string& value);
  inline void add_hotel(const char* value);
  inline void add_hotel(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hotel() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hotel();
  
  // repeated string lvid_cater_hotel = 5;
  inline int lvid_cater_hotel_size() const;
  inline void clear_lvid_cater_hotel();
  static const int kLvidCaterHotelFieldNumber = 5;
  inline const ::std::string& lvid_cater_hotel(int index) const;
  inline ::std::string* mutable_lvid_cater_hotel(int index);
  inline void set_lvid_cater_hotel(int index, const ::std::string& value);
  inline void set_lvid_cater_hotel(int index, const char* value);
  inline void set_lvid_cater_hotel(int index, const char* value, size_t size);
  inline ::std::string* add_lvid_cater_hotel();
  inline void add_lvid_cater_hotel(const ::std::string& value);
  inline void add_lvid_cater_hotel(const char* value);
  inline void add_lvid_cater_hotel(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lvid_cater_hotel() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lvid_cater_hotel();
  
  // optional string opt_json_str = 6;
  inline bool has_opt_json_str() const;
  inline void clear_opt_json_str();
  static const int kOptJsonStrFieldNumber = 6;
  inline const ::std::string& opt_json_str() const;
  inline void set_opt_json_str(const ::std::string& value);
  inline void set_opt_json_str(const char* value);
  inline void set_opt_json_str(const char* value, size_t size);
  inline ::std::string* mutable_opt_json_str();
  inline ::std::string* release_opt_json_str();
  
  // repeated .lbs.da.openservice.Arg args = 7;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 7;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.DayRouteInfo)
 private:
  inline void set_has_scene_dura_time();
  inline void clear_has_scene_dura_time();
  inline void set_has_opt_json_str();
  inline void clear_has_opt_json_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> lv_id_;
  double scene_dura_time_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cater_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hotel_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lvid_cater_hotel_;
  ::std::string* opt_json_str_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static DayRouteInfo* default_instance_;
};
// -------------------------------------------------------------------

class LvTripPlanRequest : public ::google::protobuf::Message {
 public:
  LvTripPlanRequest();
  virtual ~LvTripPlanRequest();
  
  LvTripPlanRequest(const LvTripPlanRequest& from);
  
  inline LvTripPlanRequest& operator=(const LvTripPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LvTripPlanRequest& default_instance();
  
  void Swap(LvTripPlanRequest* other);
  
  // implements Message ----------------------------------------------
  
  LvTripPlanRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LvTripPlanRequest& from);
  void MergeFrom(const LvTripPlanRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // repeated string lv_id = 2;
  inline int lv_id_size() const;
  inline void clear_lv_id();
  static const int kLvIdFieldNumber = 2;
  inline const ::std::string& lv_id(int index) const;
  inline ::std::string* mutable_lv_id(int index);
  inline void set_lv_id(int index, const ::std::string& value);
  inline void set_lv_id(int index, const char* value);
  inline void set_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_lv_id();
  inline void add_lv_id(const ::std::string& value);
  inline void add_lv_id(const char* value);
  inline void add_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lv_id();
  
  // optional string userid = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 3;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional string algorithmId = 4;
  inline bool has_algorithmid() const;
  inline void clear_algorithmid();
  static const int kAlgorithmIdFieldNumber = 4;
  inline const ::std::string& algorithmid() const;
  inline void set_algorithmid(const ::std::string& value);
  inline void set_algorithmid(const char* value);
  inline void set_algorithmid(const char* value, size_t size);
  inline ::std::string* mutable_algorithmid();
  inline ::std::string* release_algorithmid();
  
  // repeated string cater = 5;
  inline int cater_size() const;
  inline void clear_cater();
  static const int kCaterFieldNumber = 5;
  inline const ::std::string& cater(int index) const;
  inline ::std::string* mutable_cater(int index);
  inline void set_cater(int index, const ::std::string& value);
  inline void set_cater(int index, const char* value);
  inline void set_cater(int index, const char* value, size_t size);
  inline ::std::string* add_cater();
  inline void add_cater(const ::std::string& value);
  inline void add_cater(const char* value);
  inline void add_cater(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cater() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cater();
  
  // repeated string hotel = 6;
  inline int hotel_size() const;
  inline void clear_hotel();
  static const int kHotelFieldNumber = 6;
  inline const ::std::string& hotel(int index) const;
  inline ::std::string* mutable_hotel(int index);
  inline void set_hotel(int index, const ::std::string& value);
  inline void set_hotel(int index, const char* value);
  inline void set_hotel(int index, const char* value, size_t size);
  inline ::std::string* add_hotel();
  inline void add_hotel(const ::std::string& value);
  inline void add_hotel(const char* value);
  inline void add_hotel(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hotel() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hotel();
  
  // optional string opt_json_str = 7;
  inline bool has_opt_json_str() const;
  inline void clear_opt_json_str();
  static const int kOptJsonStrFieldNumber = 7;
  inline const ::std::string& opt_json_str() const;
  inline void set_opt_json_str(const ::std::string& value);
  inline void set_opt_json_str(const char* value);
  inline void set_opt_json_str(const char* value, size_t size);
  inline ::std::string* mutable_opt_json_str();
  inline ::std::string* release_opt_json_str();
  
  // repeated .lbs.da.openservice.Arg args = 8;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 8;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.LvTripPlanRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_algorithmid();
  inline void clear_has_algorithmid();
  inline void set_has_opt_json_str();
  inline void clear_has_opt_json_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lv_id_;
  ::std::string* userid_;
  ::std::string* algorithmid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cater_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hotel_;
  ::std::string* opt_json_str_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static LvTripPlanRequest* default_instance_;
};
// -------------------------------------------------------------------

class LvTripPlanResponse : public ::google::protobuf::Message {
 public:
  LvTripPlanResponse();
  virtual ~LvTripPlanResponse();
  
  LvTripPlanResponse(const LvTripPlanResponse& from);
  
  inline LvTripPlanResponse& operator=(const LvTripPlanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LvTripPlanResponse& default_instance();
  
  void Swap(LvTripPlanResponse* other);
  
  // implements Message ----------------------------------------------
  
  LvTripPlanResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LvTripPlanResponse& from);
  void MergeFrom(const LvTripPlanResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required int64 original_total_distance = 2;
  inline bool has_original_total_distance() const;
  inline void clear_original_total_distance();
  static const int kOriginalTotalDistanceFieldNumber = 2;
  inline ::google::protobuf::int64 original_total_distance() const;
  inline void set_original_total_distance(::google::protobuf::int64 value);
  
  // required int64 original_total_time = 3;
  inline bool has_original_total_time() const;
  inline void clear_original_total_time();
  static const int kOriginalTotalTimeFieldNumber = 3;
  inline ::google::protobuf::int64 original_total_time() const;
  inline void set_original_total_time(::google::protobuf::int64 value);
  
  // required int64 planned_total_distance = 4;
  inline bool has_planned_total_distance() const;
  inline void clear_planned_total_distance();
  static const int kPlannedTotalDistanceFieldNumber = 4;
  inline ::google::protobuf::int64 planned_total_distance() const;
  inline void set_planned_total_distance(::google::protobuf::int64 value);
  
  // required int64 planned_total_time = 5;
  inline bool has_planned_total_time() const;
  inline void clear_planned_total_time();
  static const int kPlannedTotalTimeFieldNumber = 5;
  inline ::google::protobuf::int64 planned_total_time() const;
  inline void set_planned_total_time(::google::protobuf::int64 value);
  
  // repeated string lv_id = 8;
  inline int lv_id_size() const;
  inline void clear_lv_id();
  static const int kLvIdFieldNumber = 8;
  inline const ::std::string& lv_id(int index) const;
  inline ::std::string* mutable_lv_id(int index);
  inline void set_lv_id(int index, const ::std::string& value);
  inline void set_lv_id(int index, const char* value);
  inline void set_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_lv_id();
  inline void add_lv_id(const ::std::string& value);
  inline void add_lv_id(const char* value);
  inline void add_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lv_id();
  
  // repeated .lbs.da.openservice.DayRouteInfo dayroute = 9;
  inline int dayroute_size() const;
  inline void clear_dayroute();
  static const int kDayrouteFieldNumber = 9;
  inline const ::lbs::da::openservice::DayRouteInfo& dayroute(int index) const;
  inline ::lbs::da::openservice::DayRouteInfo* mutable_dayroute(int index);
  inline ::lbs::da::openservice::DayRouteInfo* add_dayroute();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRouteInfo >&
      dayroute() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRouteInfo >*
      mutable_dayroute();
  
  // repeated string origin_lv_id = 10;
  inline int origin_lv_id_size() const;
  inline void clear_origin_lv_id();
  static const int kOriginLvIdFieldNumber = 10;
  inline const ::std::string& origin_lv_id(int index) const;
  inline ::std::string* mutable_origin_lv_id(int index);
  inline void set_origin_lv_id(int index, const ::std::string& value);
  inline void set_origin_lv_id(int index, const char* value);
  inline void set_origin_lv_id(int index, const char* value, size_t size);
  inline ::std::string* add_origin_lv_id();
  inline void add_origin_lv_id(const ::std::string& value);
  inline void add_origin_lv_id(const char* value);
  inline void add_origin_lv_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& origin_lv_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_origin_lv_id();
  
  // optional string userid = 11;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 11;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // optional string uniq_id = 12;
  inline bool has_uniq_id() const;
  inline void clear_uniq_id();
  static const int kUniqIdFieldNumber = 12;
  inline const ::std::string& uniq_id() const;
  inline void set_uniq_id(const ::std::string& value);
  inline void set_uniq_id(const char* value);
  inline void set_uniq_id(const char* value, size_t size);
  inline ::std::string* mutable_uniq_id();
  inline ::std::string* release_uniq_id();
  
  // optional string opt_json_str = 13;
  inline bool has_opt_json_str() const;
  inline void clear_opt_json_str();
  static const int kOptJsonStrFieldNumber = 13;
  inline const ::std::string& opt_json_str() const;
  inline void set_opt_json_str(const ::std::string& value);
  inline void set_opt_json_str(const char* value);
  inline void set_opt_json_str(const char* value, size_t size);
  inline ::std::string* mutable_opt_json_str();
  inline ::std::string* release_opt_json_str();
  
  // repeated .lbs.da.openservice.Arg args = 14;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 14;
  inline const ::lbs::da::openservice::Arg& args(int index) const;
  inline ::lbs::da::openservice::Arg* mutable_args(int index);
  inline ::lbs::da::openservice::Arg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.LvTripPlanResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_original_total_distance();
  inline void clear_has_original_total_distance();
  inline void set_has_original_total_time();
  inline void clear_has_original_total_time();
  inline void set_has_planned_total_distance();
  inline void clear_has_planned_total_distance();
  inline void set_has_planned_total_time();
  inline void clear_has_planned_total_time();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_uniq_id();
  inline void clear_has_uniq_id();
  inline void set_has_opt_json_str();
  inline void clear_has_opt_json_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 original_total_distance_;
  ::google::protobuf::int64 original_total_time_;
  ::google::protobuf::int64 planned_total_distance_;
  ::google::protobuf::int64 planned_total_time_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lv_id_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRouteInfo > dayroute_;
  ::google::protobuf::RepeatedPtrField< ::std::string> origin_lv_id_;
  ::std::string* userid_;
  ::std::string* uniq_id_;
  ::std::string* opt_json_str_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg > args_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static LvTripPlanResponse* default_instance_;
};
// -------------------------------------------------------------------

class WifiFinger : public ::google::protobuf::Message {
 public:
  WifiFinger();
  virtual ~WifiFinger();
  
  WifiFinger(const WifiFinger& from);
  
  inline WifiFinger& operator=(const WifiFinger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiFinger& default_instance();
  
  void Swap(WifiFinger* other);
  
  // implements Message ----------------------------------------------
  
  WifiFinger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiFinger& from);
  void MergeFrom(const WifiFinger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mac_addr = 1;
  inline bool has_mac_addr() const;
  inline void clear_mac_addr();
  static const int kMacAddrFieldNumber = 1;
  inline const ::std::string& mac_addr() const;
  inline void set_mac_addr(const ::std::string& value);
  inline void set_mac_addr(const char* value);
  inline void set_mac_addr(const char* value, size_t size);
  inline ::std::string* mutable_mac_addr();
  inline ::std::string* release_mac_addr();
  
  // required int32 strength = 2;
  inline bool has_strength() const;
  inline void clear_strength();
  static const int kStrengthFieldNumber = 2;
  inline ::google::protobuf::int32 strength() const;
  inline void set_strength(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.WifiFinger)
 private:
  inline void set_has_mac_addr();
  inline void clear_has_mac_addr();
  inline void set_has_strength();
  inline void clear_has_strength();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* mac_addr_;
  ::google::protobuf::int32 strength_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static WifiFinger* default_instance_;
};
// -------------------------------------------------------------------

class PlaceSemanticRequest : public ::google::protobuf::Message {
 public:
  PlaceSemanticRequest();
  virtual ~PlaceSemanticRequest();
  
  PlaceSemanticRequest(const PlaceSemanticRequest& from);
  
  inline PlaceSemanticRequest& operator=(const PlaceSemanticRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaceSemanticRequest& default_instance();
  
  void Swap(PlaceSemanticRequest* other);
  
  // implements Message ----------------------------------------------
  
  PlaceSemanticRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaceSemanticRequest& from);
  void MergeFrom(const PlaceSemanticRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // repeated .lbs.da.openservice.WifiFinger wifi = 2;
  inline int wifi_size() const;
  inline void clear_wifi();
  static const int kWifiFieldNumber = 2;
  inline const ::lbs::da::openservice::WifiFinger& wifi(int index) const;
  inline ::lbs::da::openservice::WifiFinger* mutable_wifi(int index);
  inline ::lbs::da::openservice::WifiFinger* add_wifi();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::WifiFinger >&
      wifi() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::WifiFinger >*
      mutable_wifi();
  
  // optional double longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // optional double latitude = 4;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // optional string cuid = 5;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 5;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional int32 distance = 6;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 6;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);
  
  // optional double similarity_threadhold = 7;
  inline bool has_similarity_threadhold() const;
  inline void clear_similarity_threadhold();
  static const int kSimilarityThreadholdFieldNumber = 7;
  inline double similarity_threadhold() const;
  inline void set_similarity_threadhold(double value);
  
  // optional string algorithm_id = 8;
  inline bool has_algorithm_id() const;
  inline void clear_algorithm_id();
  static const int kAlgorithmIdFieldNumber = 8;
  inline const ::std::string& algorithm_id() const;
  inline void set_algorithm_id(const ::std::string& value);
  inline void set_algorithm_id(const char* value);
  inline void set_algorithm_id(const char* value, size_t size);
  inline ::std::string* mutable_algorithm_id();
  inline ::std::string* release_algorithm_id();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.PlaceSemanticRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_similarity_threadhold();
  inline void clear_has_similarity_threadhold();
  inline void set_has_algorithm_id();
  inline void clear_has_algorithm_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::WifiFinger > wifi_;
  double longitude_;
  double latitude_;
  ::std::string* cuid_;
  double similarity_threadhold_;
  ::std::string* algorithm_id_;
  ::google::protobuf::int32 distance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static PlaceSemanticRequest* default_instance_;
};
// -------------------------------------------------------------------

class PoiProbability : public ::google::protobuf::Message {
 public:
  PoiProbability();
  virtual ~PoiProbability();
  
  PoiProbability(const PoiProbability& from);
  
  inline PoiProbability& operator=(const PoiProbability& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoiProbability& default_instance();
  
  void Swap(PoiProbability* other);
  
  // implements Message ----------------------------------------------
  
  PoiProbability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoiProbability& from);
  void MergeFrom(const PoiProbability& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string poi = 1;
  inline bool has_poi() const;
  inline void clear_poi();
  static const int kPoiFieldNumber = 1;
  inline const ::std::string& poi() const;
  inline void set_poi(const ::std::string& value);
  inline void set_poi(const char* value);
  inline void set_poi(const char* value, size_t size);
  inline ::std::string* mutable_poi();
  inline ::std::string* release_poi();
  
  // required double probability = 2;
  inline bool has_probability() const;
  inline void clear_probability();
  static const int kProbabilityFieldNumber = 2;
  inline double probability() const;
  inline void set_probability(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.PoiProbability)
 private:
  inline void set_has_poi();
  inline void clear_has_poi();
  inline void set_has_probability();
  inline void clear_has_probability();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* poi_;
  double probability_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static PoiProbability* default_instance_;
};
// -------------------------------------------------------------------

class PlaceSemanticResponse : public ::google::protobuf::Message {
 public:
  PlaceSemanticResponse();
  virtual ~PlaceSemanticResponse();
  
  PlaceSemanticResponse(const PlaceSemanticResponse& from);
  
  inline PlaceSemanticResponse& operator=(const PlaceSemanticResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaceSemanticResponse& default_instance();
  
  void Swap(PlaceSemanticResponse* other);
  
  // implements Message ----------------------------------------------
  
  PlaceSemanticResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaceSemanticResponse& from);
  void MergeFrom(const PlaceSemanticResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string aoi_id = 1;
  inline int aoi_id_size() const;
  inline void clear_aoi_id();
  static const int kAoiIdFieldNumber = 1;
  inline const ::std::string& aoi_id(int index) const;
  inline ::std::string* mutable_aoi_id(int index);
  inline void set_aoi_id(int index, const ::std::string& value);
  inline void set_aoi_id(int index, const char* value);
  inline void set_aoi_id(int index, const char* value, size_t size);
  inline ::std::string* add_aoi_id();
  inline void add_aoi_id(const ::std::string& value);
  inline void add_aoi_id(const char* value);
  inline void add_aoi_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& aoi_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_aoi_id();
  
  // repeated .lbs.da.openservice.PoiProbability poi_prob_list = 2;
  inline int poi_prob_list_size() const;
  inline void clear_poi_prob_list();
  static const int kPoiProbListFieldNumber = 2;
  inline const ::lbs::da::openservice::PoiProbability& poi_prob_list(int index) const;
  inline ::lbs::da::openservice::PoiProbability* mutable_poi_prob_list(int index);
  inline ::lbs::da::openservice::PoiProbability* add_poi_prob_list();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiProbability >&
      poi_prob_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiProbability >*
      mutable_poi_prob_list();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.PlaceSemanticResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> aoi_id_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiProbability > poi_prob_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static PlaceSemanticResponse* default_instance_;
};
// -------------------------------------------------------------------

class NuomiUserPreferenceRequest : public ::google::protobuf::Message {
 public:
  NuomiUserPreferenceRequest();
  virtual ~NuomiUserPreferenceRequest();
  
  NuomiUserPreferenceRequest(const NuomiUserPreferenceRequest& from);
  
  inline NuomiUserPreferenceRequest& operator=(const NuomiUserPreferenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NuomiUserPreferenceRequest& default_instance();
  
  void Swap(NuomiUserPreferenceRequest* other);
  
  // implements Message ----------------------------------------------
  
  NuomiUserPreferenceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NuomiUserPreferenceRequest& from);
  void MergeFrom(const NuomiUserPreferenceRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // required .lbs.da.openservice.RequestIdType id_type = 2;
  inline bool has_id_type() const;
  inline void clear_id_type();
  static const int kIdTypeFieldNumber = 2;
  inline lbs::da::openservice::RequestIdType id_type() const;
  inline void set_id_type(lbs::da::openservice::RequestIdType value);
  
  // required string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional .lbs.da.openservice.NuomiDataType data_type = 4;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  inline lbs::da::openservice::NuomiDataType data_type() const;
  inline void set_data_type(lbs::da::openservice::NuomiDataType value);
  
  // repeated string feature_names = 5;
  inline int feature_names_size() const;
  inline void clear_feature_names();
  static const int kFeatureNamesFieldNumber = 5;
  inline const ::std::string& feature_names(int index) const;
  inline ::std::string* mutable_feature_names(int index);
  inline void set_feature_names(int index, const ::std::string& value);
  inline void set_feature_names(int index, const char* value);
  inline void set_feature_names(int index, const char* value, size_t size);
  inline ::std::string* add_feature_names();
  inline void add_feature_names(const ::std::string& value);
  inline void add_feature_names(const char* value);
  inline void add_feature_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& feature_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_feature_names();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.NuomiUserPreferenceRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_id_type();
  inline void clear_has_id_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* id_;
  int id_type_;
  int data_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> feature_names_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static NuomiUserPreferenceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ScoreInfo : public ::google::protobuf::Message {
 public:
  ScoreInfo();
  virtual ~ScoreInfo();
  
  ScoreInfo(const ScoreInfo& from);
  
  inline ScoreInfo& operator=(const ScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreInfo& default_instance();
  
  void Swap(ScoreInfo* other);
  
  // implements Message ----------------------------------------------
  
  ScoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoreInfo& from);
  void MergeFrom(const ScoreInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string featureid = 1;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureidFieldNumber = 1;
  inline const ::std::string& featureid() const;
  inline void set_featureid(const ::std::string& value);
  inline void set_featureid(const char* value);
  inline void set_featureid(const char* value, size_t size);
  inline ::std::string* mutable_featureid();
  inline ::std::string* release_featureid();
  
  // required double score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline double score() const;
  inline void set_score(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ScoreInfo)
 private:
  inline void set_has_featureid();
  inline void clear_has_featureid();
  inline void set_has_score();
  inline void clear_has_score();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* featureid_;
  double score_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static ScoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class FeatureInfo : public ::google::protobuf::Message {
 public:
  FeatureInfo();
  virtual ~FeatureInfo();
  
  FeatureInfo(const FeatureInfo& from);
  
  inline FeatureInfo& operator=(const FeatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureInfo& default_instance();
  
  void Swap(FeatureInfo* other);
  
  // implements Message ----------------------------------------------
  
  FeatureInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureInfo& from);
  void MergeFrom(const FeatureInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string feature_name = 1;
  inline bool has_feature_name() const;
  inline void clear_feature_name();
  static const int kFeatureNameFieldNumber = 1;
  inline const ::std::string& feature_name() const;
  inline void set_feature_name(const ::std::string& value);
  inline void set_feature_name(const char* value);
  inline void set_feature_name(const char* value, size_t size);
  inline ::std::string* mutable_feature_name();
  inline ::std::string* release_feature_name();
  
  // required .lbs.da.openservice.ScoreInfo score_info = 2;
  inline bool has_score_info() const;
  inline void clear_score_info();
  static const int kScoreInfoFieldNumber = 2;
  inline const ::lbs::da::openservice::ScoreInfo& score_info() const;
  inline ::lbs::da::openservice::ScoreInfo* mutable_score_info();
  inline ::lbs::da::openservice::ScoreInfo* release_score_info();
  
  // optional .lbs.da.openservice.NuomiDataType data_type = 3;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  inline lbs::da::openservice::NuomiDataType data_type() const;
  inline void set_data_type(lbs::da::openservice::NuomiDataType value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.FeatureInfo)
 private:
  inline void set_has_feature_name();
  inline void clear_has_feature_name();
  inline void set_has_score_info();
  inline void clear_has_score_info();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* feature_name_;
  ::lbs::da::openservice::ScoreInfo* score_info_;
  int data_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static FeatureInfo* default_instance_;
};
// -------------------------------------------------------------------

class StrInfo : public ::google::protobuf::Message {
 public:
  StrInfo();
  virtual ~StrInfo();
  
  StrInfo(const StrInfo& from);
  
  inline StrInfo& operator=(const StrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrInfo& default_instance();
  
  void Swap(StrInfo* other);
  
  // implements Message ----------------------------------------------
  
  StrInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrInfo& from);
  void MergeFrom(const StrInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string featureid = 1;
  inline bool has_featureid() const;
  inline void clear_featureid();
  static const int kFeatureidFieldNumber = 1;
  inline const ::std::string& featureid() const;
  inline void set_featureid(const ::std::string& value);
  inline void set_featureid(const char* value);
  inline void set_featureid(const char* value, size_t size);
  inline ::std::string* mutable_featureid();
  inline ::std::string* release_featureid();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.StrInfo)
 private:
  inline void set_has_featureid();
  inline void clear_has_featureid();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* featureid_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static StrInfo* default_instance_;
};
// -------------------------------------------------------------------

class StrFeatureInfo : public ::google::protobuf::Message {
 public:
  StrFeatureInfo();
  virtual ~StrFeatureInfo();
  
  StrFeatureInfo(const StrFeatureInfo& from);
  
  inline StrFeatureInfo& operator=(const StrFeatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrFeatureInfo& default_instance();
  
  void Swap(StrFeatureInfo* other);
  
  // implements Message ----------------------------------------------
  
  StrFeatureInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrFeatureInfo& from);
  void MergeFrom(const StrFeatureInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string feature_name = 1;
  inline bool has_feature_name() const;
  inline void clear_feature_name();
  static const int kFeatureNameFieldNumber = 1;
  inline const ::std::string& feature_name() const;
  inline void set_feature_name(const ::std::string& value);
  inline void set_feature_name(const char* value);
  inline void set_feature_name(const char* value, size_t size);
  inline ::std::string* mutable_feature_name();
  inline ::std::string* release_feature_name();
  
  // required .lbs.da.openservice.StrInfo str_info = 2;
  inline bool has_str_info() const;
  inline void clear_str_info();
  static const int kStrInfoFieldNumber = 2;
  inline const ::lbs::da::openservice::StrInfo& str_info() const;
  inline ::lbs::da::openservice::StrInfo* mutable_str_info();
  inline ::lbs::da::openservice::StrInfo* release_str_info();
  
  // optional .lbs.da.openservice.NuomiDataType data_type = 3;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  inline lbs::da::openservice::NuomiDataType data_type() const;
  inline void set_data_type(lbs::da::openservice::NuomiDataType value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.StrFeatureInfo)
 private:
  inline void set_has_feature_name();
  inline void clear_has_feature_name();
  inline void set_has_str_info();
  inline void clear_has_str_info();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* feature_name_;
  ::lbs::da::openservice::StrInfo* str_info_;
  int data_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static StrFeatureInfo* default_instance_;
};
// -------------------------------------------------------------------

class ItemUpInfo : public ::google::protobuf::Message {
 public:
  ItemUpInfo();
  virtual ~ItemUpInfo();
  
  ItemUpInfo(const ItemUpInfo& from);
  
  inline ItemUpInfo& operator=(const ItemUpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemUpInfo& default_instance();
  
  void Swap(ItemUpInfo* other);
  
  // implements Message ----------------------------------------------
  
  ItemUpInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemUpInfo& from);
  void MergeFrom(const ItemUpInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional double score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline double score() const;
  inline void set_score(double value);
  
  // optional string info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // optional string date = 4;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.ItemUpInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_date();
  inline void clear_has_date();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  double score_;
  ::std::string* info_;
  ::std::string* date_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static ItemUpInfo* default_instance_;
};
// -------------------------------------------------------------------

class NuomiUserPreferenceResponse : public ::google::protobuf::Message {
 public:
  NuomiUserPreferenceResponse();
  virtual ~NuomiUserPreferenceResponse();
  
  NuomiUserPreferenceResponse(const NuomiUserPreferenceResponse& from);
  
  inline NuomiUserPreferenceResponse& operator=(const NuomiUserPreferenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NuomiUserPreferenceResponse& default_instance();
  
  void Swap(NuomiUserPreferenceResponse* other);
  
  // implements Message ----------------------------------------------
  
  NuomiUserPreferenceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NuomiUserPreferenceResponse& from);
  void MergeFrom(const NuomiUserPreferenceResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.FeatureInfo features = 1;
  inline int features_size() const;
  inline void clear_features();
  static const int kFeaturesFieldNumber = 1;
  inline const ::lbs::da::openservice::FeatureInfo& features(int index) const;
  inline ::lbs::da::openservice::FeatureInfo* mutable_features(int index);
  inline ::lbs::da::openservice::FeatureInfo* add_features();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::FeatureInfo >&
      features() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::FeatureInfo >*
      mutable_features();
  
  // optional .lbs.da.openservice.NuomiUpResultType result_type = 2;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 2;
  inline lbs::da::openservice::NuomiUpResultType result_type() const;
  inline void set_result_type(lbs::da::openservice::NuomiUpResultType value);
  
  // optional string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // repeated .lbs.da.openservice.StrFeatureInfo other_infos = 4;
  inline int other_infos_size() const;
  inline void clear_other_infos();
  static const int kOtherInfosFieldNumber = 4;
  inline const ::lbs::da::openservice::StrFeatureInfo& other_infos(int index) const;
  inline ::lbs::da::openservice::StrFeatureInfo* mutable_other_infos(int index);
  inline ::lbs::da::openservice::StrFeatureInfo* add_other_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StrFeatureInfo >&
      other_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StrFeatureInfo >*
      mutable_other_infos();
  
  // repeated .lbs.da.openservice.ItemUpInfo item_infos = 5;
  inline int item_infos_size() const;
  inline void clear_item_infos();
  static const int kItemInfosFieldNumber = 5;
  inline const ::lbs::da::openservice::ItemUpInfo& item_infos(int index) const;
  inline ::lbs::da::openservice::ItemUpInfo* mutable_item_infos(int index);
  inline ::lbs::da::openservice::ItemUpInfo* add_item_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemUpInfo >&
      item_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemUpInfo >*
      mutable_item_infos();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.NuomiUserPreferenceResponse)
 private:
  inline void set_has_result_type();
  inline void clear_has_result_type();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::FeatureInfo > features_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StrFeatureInfo > other_infos_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemUpInfo > item_infos_;
  int result_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static NuomiUserPreferenceResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAOIRequest : public ::google::protobuf::Message {
 public:
  GetAOIRequest();
  virtual ~GetAOIRequest();
  
  GetAOIRequest(const GetAOIRequest& from);
  
  inline GetAOIRequest& operator=(const GetAOIRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAOIRequest& default_instance();
  
  void Swap(GetAOIRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetAOIRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAOIRequest& from);
  void MergeFrom(const GetAOIRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // optional string cuid = 2;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 2;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional double mercator_x = 3;
  inline bool has_mercator_x() const;
  inline void clear_mercator_x();
  static const int kMercatorXFieldNumber = 3;
  inline double mercator_x() const;
  inline void set_mercator_x(double value);
  
  // optional double mercator_y = 4;
  inline bool has_mercator_y() const;
  inline void clear_mercator_y();
  static const int kMercatorYFieldNumber = 4;
  inline double mercator_y() const;
  inline void set_mercator_y(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetAOIRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_mercator_x();
  inline void clear_has_mercator_x();
  inline void set_has_mercator_y();
  inline void clear_has_mercator_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::std::string* cuid_;
  double mercator_x_;
  double mercator_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetAOIRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAOIResponse : public ::google::protobuf::Message {
 public:
  GetAOIResponse();
  virtual ~GetAOIResponse();
  
  GetAOIResponse(const GetAOIResponse& from);
  
  inline GetAOIResponse& operator=(const GetAOIResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAOIResponse& default_instance();
  
  void Swap(GetAOIResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetAOIResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAOIResponse& from);
  void MergeFrom(const GetAOIResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string aoi_id = 1;
  inline int aoi_id_size() const;
  inline void clear_aoi_id();
  static const int kAoiIdFieldNumber = 1;
  inline const ::std::string& aoi_id(int index) const;
  inline ::std::string* mutable_aoi_id(int index);
  inline void set_aoi_id(int index, const ::std::string& value);
  inline void set_aoi_id(int index, const char* value);
  inline void set_aoi_id(int index, const char* value, size_t size);
  inline ::std::string* add_aoi_id();
  inline void add_aoi_id(const ::std::string& value);
  inline void add_aoi_id(const char* value);
  inline void add_aoi_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& aoi_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_aoi_id();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetAOIResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> aoi_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetAOIResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetNearPoiRequest : public ::google::protobuf::Message {
 public:
  GetNearPoiRequest();
  virtual ~GetNearPoiRequest();
  
  GetNearPoiRequest(const GetNearPoiRequest& from);
  
  inline GetNearPoiRequest& operator=(const GetNearPoiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNearPoiRequest& default_instance();
  
  void Swap(GetNearPoiRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetNearPoiRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNearPoiRequest& from);
  void MergeFrom(const GetNearPoiRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // optional double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // optional double latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // optional double radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline double radius() const;
  inline void set_radius(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetNearPoiRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_radius();
  inline void clear_has_radius();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  double longitude_;
  double latitude_;
  double radius_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetNearPoiRequest* default_instance_;
};
// -------------------------------------------------------------------

class PoiInfo : public ::google::protobuf::Message {
 public:
  PoiInfo();
  virtual ~PoiInfo();
  
  PoiInfo(const PoiInfo& from);
  
  inline PoiInfo& operator=(const PoiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoiInfo& default_instance();
  
  void Swap(PoiInfo* other);
  
  // implements Message ----------------------------------------------
  
  PoiInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoiInfo& from);
  void MergeFrom(const PoiInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string poi = 1;
  inline bool has_poi() const;
  inline void clear_poi();
  static const int kPoiFieldNumber = 1;
  inline const ::std::string& poi() const;
  inline void set_poi(const ::std::string& value);
  inline void set_poi(const char* value);
  inline void set_poi(const char* value, size_t size);
  inline ::std::string* mutable_poi();
  inline ::std::string* release_poi();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional double longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // optional double latitude = 4;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.PoiInfo)
 private:
  inline void set_has_poi();
  inline void clear_has_poi();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* poi_;
  ::std::string* name_;
  double longitude_;
  double latitude_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static PoiInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetNearPoiResponse : public ::google::protobuf::Message {
 public:
  GetNearPoiResponse();
  virtual ~GetNearPoiResponse();
  
  GetNearPoiResponse(const GetNearPoiResponse& from);
  
  inline GetNearPoiResponse& operator=(const GetNearPoiResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNearPoiResponse& default_instance();
  
  void Swap(GetNearPoiResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetNearPoiResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNearPoiResponse& from);
  void MergeFrom(const GetNearPoiResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.PoiInfo poi_list = 1;
  inline int poi_list_size() const;
  inline void clear_poi_list();
  static const int kPoiListFieldNumber = 1;
  inline const ::lbs::da::openservice::PoiInfo& poi_list(int index) const;
  inline ::lbs::da::openservice::PoiInfo* mutable_poi_list(int index);
  inline ::lbs::da::openservice::PoiInfo* add_poi_list();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >&
      poi_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >*
      mutable_poi_list();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.GetNearPoiResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo > poi_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pbrpc_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2eproto();
  
  void InitAsDefaultInstance();
  static GetNearPoiResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// RequestHeader

// optional string servicekey = 1;
inline bool RequestHeader::has_servicekey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHeader::set_has_servicekey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHeader::clear_has_servicekey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHeader::clear_servicekey() {
  if (servicekey_ != &::google::protobuf::internal::kEmptyString) {
    servicekey_->clear();
  }
  clear_has_servicekey();
}
inline const ::std::string& RequestHeader::servicekey() const {
  return *servicekey_;
}
inline void RequestHeader::set_servicekey(const ::std::string& value) {
  set_has_servicekey();
  if (servicekey_ == &::google::protobuf::internal::kEmptyString) {
    servicekey_ = new ::std::string;
  }
  servicekey_->assign(value);
}
inline void RequestHeader::set_servicekey(const char* value) {
  set_has_servicekey();
  if (servicekey_ == &::google::protobuf::internal::kEmptyString) {
    servicekey_ = new ::std::string;
  }
  servicekey_->assign(value);
}
inline void RequestHeader::set_servicekey(const char* value, size_t size) {
  set_has_servicekey();
  if (servicekey_ == &::google::protobuf::internal::kEmptyString) {
    servicekey_ = new ::std::string;
  }
  servicekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHeader::mutable_servicekey() {
  set_has_servicekey();
  if (servicekey_ == &::google::protobuf::internal::kEmptyString) {
    servicekey_ = new ::std::string;
  }
  return servicekey_;
}
inline ::std::string* RequestHeader::release_servicekey() {
  clear_has_servicekey();
  if (servicekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servicekey_;
    servicekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string secretkey = 2;
inline bool RequestHeader::has_secretkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHeader::set_has_secretkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHeader::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHeader::clear_secretkey() {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& RequestHeader::secretkey() const {
  return *secretkey_;
}
inline void RequestHeader::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void RequestHeader::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void RequestHeader::set_secretkey(const char* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHeader::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  return secretkey_;
}
inline ::std::string* RequestHeader::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subservice = 3;
inline bool RequestHeader::has_subservice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestHeader::set_has_subservice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestHeader::clear_has_subservice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestHeader::clear_subservice() {
  if (subservice_ != &::google::protobuf::internal::kEmptyString) {
    subservice_->clear();
  }
  clear_has_subservice();
}
inline const ::std::string& RequestHeader::subservice() const {
  return *subservice_;
}
inline void RequestHeader::set_subservice(const ::std::string& value) {
  set_has_subservice();
  if (subservice_ == &::google::protobuf::internal::kEmptyString) {
    subservice_ = new ::std::string;
  }
  subservice_->assign(value);
}
inline void RequestHeader::set_subservice(const char* value) {
  set_has_subservice();
  if (subservice_ == &::google::protobuf::internal::kEmptyString) {
    subservice_ = new ::std::string;
  }
  subservice_->assign(value);
}
inline void RequestHeader::set_subservice(const char* value, size_t size) {
  set_has_subservice();
  if (subservice_ == &::google::protobuf::internal::kEmptyString) {
    subservice_ = new ::std::string;
  }
  subservice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHeader::mutable_subservice() {
  set_has_subservice();
  if (subservice_ == &::google::protobuf::internal::kEmptyString) {
    subservice_ = new ::std::string;
  }
  return subservice_;
}
inline ::std::string* RequestHeader::release_subservice() {
  clear_has_subservice();
  if (subservice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subservice_;
    subservice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Arg

// required string name = 1;
inline bool Arg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Arg::name() const {
  return *name_;
}
inline void Arg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Arg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Arg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Arg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 int_v = 2;
inline bool Arg::has_int_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arg::set_has_int_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arg::clear_has_int_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arg::clear_int_v() {
  int_v_ = GOOGLE_LONGLONG(0);
  clear_has_int_v();
}
inline ::google::protobuf::int64 Arg::int_v() const {
  return int_v_;
}
inline void Arg::set_int_v(::google::protobuf::int64 value) {
  set_has_int_v();
  int_v_ = value;
}

// optional double double_v = 3;
inline bool Arg::has_double_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Arg::set_has_double_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Arg::clear_has_double_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Arg::clear_double_v() {
  double_v_ = 0;
  clear_has_double_v();
}
inline double Arg::double_v() const {
  return double_v_;
}
inline void Arg::set_double_v(double value) {
  set_has_double_v();
  double_v_ = value;
}

// optional string str_v = 4;
inline bool Arg::has_str_v() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Arg::set_has_str_v() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Arg::clear_has_str_v() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Arg::clear_str_v() {
  if (str_v_ != &::google::protobuf::internal::kEmptyString) {
    str_v_->clear();
  }
  clear_has_str_v();
}
inline const ::std::string& Arg::str_v() const {
  return *str_v_;
}
inline void Arg::set_str_v(const ::std::string& value) {
  set_has_str_v();
  if (str_v_ == &::google::protobuf::internal::kEmptyString) {
    str_v_ = new ::std::string;
  }
  str_v_->assign(value);
}
inline void Arg::set_str_v(const char* value) {
  set_has_str_v();
  if (str_v_ == &::google::protobuf::internal::kEmptyString) {
    str_v_ = new ::std::string;
  }
  str_v_->assign(value);
}
inline void Arg::set_str_v(const char* value, size_t size) {
  set_has_str_v();
  if (str_v_ == &::google::protobuf::internal::kEmptyString) {
    str_v_ = new ::std::string;
  }
  str_v_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arg::mutable_str_v() {
  set_has_str_v();
  if (str_v_ == &::google::protobuf::internal::kEmptyString) {
    str_v_ = new ::std::string;
  }
  return str_v_;
}
inline ::std::string* Arg::release_str_v() {
  clear_has_str_v();
  if (str_v_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_v_;
    str_v_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg elements = 5;
inline int Arg::elements_size() const {
  return elements_.size();
}
inline void Arg::clear_elements() {
  elements_.Clear();
}
inline const ::lbs::da::openservice::Arg& Arg::elements(int index) const {
  return elements_.Get(index);
}
inline ::lbs::da::openservice::Arg* Arg::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* Arg::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
Arg::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
Arg::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// UserPreferenceTags

// repeated string values = 1;
inline int UserPreferenceTags::values_size() const {
  return values_.size();
}
inline void UserPreferenceTags::clear_values() {
  values_.Clear();
}
inline const ::std::string& UserPreferenceTags::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* UserPreferenceTags::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void UserPreferenceTags::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void UserPreferenceTags::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void UserPreferenceTags::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPreferenceTags::add_values() {
  return values_.Add();
}
inline void UserPreferenceTags::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void UserPreferenceTags::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void UserPreferenceTags::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserPreferenceTags::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserPreferenceTags::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// UserPreference

// required string tag = 1;
inline bool UserPreference::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPreference::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPreference::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPreference::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& UserPreference::tag() const {
  return *tag_;
}
inline void UserPreference::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void UserPreference::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void UserPreference::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPreference::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* UserPreference::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 level = 2;
inline bool UserPreference::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPreference::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPreference::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPreference::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UserPreference::level() const {
  return level_;
}
inline void UserPreference::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional float value = 3;
inline bool UserPreference::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPreference::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPreference::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPreference::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float UserPreference::value() const {
  return value_;
}
inline void UserPreference::set_value(float value) {
  set_has_value();
  value_ = value;
}

// optional string srcType = 4;
inline bool UserPreference::has_srctype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPreference::set_has_srctype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPreference::clear_has_srctype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPreference::clear_srctype() {
  if (srctype_ != &::google::protobuf::internal::kEmptyString) {
    srctype_->clear();
  }
  clear_has_srctype();
}
inline const ::std::string& UserPreference::srctype() const {
  return *srctype_;
}
inline void UserPreference::set_srctype(const ::std::string& value) {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  srctype_->assign(value);
}
inline void UserPreference::set_srctype(const char* value) {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  srctype_->assign(value);
}
inline void UserPreference::set_srctype(const char* value, size_t size) {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  srctype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPreference::mutable_srctype() {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  return srctype_;
}
inline ::std::string* UserPreference::release_srctype() {
  clear_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srctype_;
    srctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetUserPreferenceRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetUserPreferenceRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserPreferenceRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserPreferenceRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserPreferenceRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetUserPreferenceRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetUserPreferenceRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetUserPreferenceRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required string cuid = 2;
inline bool GetUserPreferenceRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserPreferenceRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserPreferenceRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserPreferenceRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetUserPreferenceRequest::cuid() const {
  return *cuid_;
}
inline void GetUserPreferenceRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetUserPreferenceRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetUserPreferenceRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserPreferenceRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetUserPreferenceRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string srcType = 3;
inline int GetUserPreferenceRequest::srctype_size() const {
  return srctype_.size();
}
inline void GetUserPreferenceRequest::clear_srctype() {
  srctype_.Clear();
}
inline const ::std::string& GetUserPreferenceRequest::srctype(int index) const {
  return srctype_.Get(index);
}
inline ::std::string* GetUserPreferenceRequest::mutable_srctype(int index) {
  return srctype_.Mutable(index);
}
inline void GetUserPreferenceRequest::set_srctype(int index, const ::std::string& value) {
  srctype_.Mutable(index)->assign(value);
}
inline void GetUserPreferenceRequest::set_srctype(int index, const char* value) {
  srctype_.Mutable(index)->assign(value);
}
inline void GetUserPreferenceRequest::set_srctype(int index, const char* value, size_t size) {
  srctype_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserPreferenceRequest::add_srctype() {
  return srctype_.Add();
}
inline void GetUserPreferenceRequest::add_srctype(const ::std::string& value) {
  srctype_.Add()->assign(value);
}
inline void GetUserPreferenceRequest::add_srctype(const char* value) {
  srctype_.Add()->assign(value);
}
inline void GetUserPreferenceRequest::add_srctype(const char* value, size_t size) {
  srctype_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUserPreferenceRequest::srctype() const {
  return srctype_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUserPreferenceRequest::mutable_srctype() {
  return &srctype_;
}

// repeated string include_tag = 4;
inline int GetUserPreferenceRequest::include_tag_size() const {
  return include_tag_.size();
}
inline void GetUserPreferenceRequest::clear_include_tag() {
  include_tag_.Clear();
}
inline const ::std::string& GetUserPreferenceRequest::include_tag(int index) const {
  return include_tag_.Get(index);
}
inline ::std::string* GetUserPreferenceRequest::mutable_include_tag(int index) {
  return include_tag_.Mutable(index);
}
inline void GetUserPreferenceRequest::set_include_tag(int index, const ::std::string& value) {
  include_tag_.Mutable(index)->assign(value);
}
inline void GetUserPreferenceRequest::set_include_tag(int index, const char* value) {
  include_tag_.Mutable(index)->assign(value);
}
inline void GetUserPreferenceRequest::set_include_tag(int index, const char* value, size_t size) {
  include_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserPreferenceRequest::add_include_tag() {
  return include_tag_.Add();
}
inline void GetUserPreferenceRequest::add_include_tag(const ::std::string& value) {
  include_tag_.Add()->assign(value);
}
inline void GetUserPreferenceRequest::add_include_tag(const char* value) {
  include_tag_.Add()->assign(value);
}
inline void GetUserPreferenceRequest::add_include_tag(const char* value, size_t size) {
  include_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUserPreferenceRequest::include_tag() const {
  return include_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUserPreferenceRequest::mutable_include_tag() {
  return &include_tag_;
}

// repeated string exclude_tag = 5;
inline int GetUserPreferenceRequest::exclude_tag_size() const {
  return exclude_tag_.size();
}
inline void GetUserPreferenceRequest::clear_exclude_tag() {
  exclude_tag_.Clear();
}
inline const ::std::string& GetUserPreferenceRequest::exclude_tag(int index) const {
  return exclude_tag_.Get(index);
}
inline ::std::string* GetUserPreferenceRequest::mutable_exclude_tag(int index) {
  return exclude_tag_.Mutable(index);
}
inline void GetUserPreferenceRequest::set_exclude_tag(int index, const ::std::string& value) {
  exclude_tag_.Mutable(index)->assign(value);
}
inline void GetUserPreferenceRequest::set_exclude_tag(int index, const char* value) {
  exclude_tag_.Mutable(index)->assign(value);
}
inline void GetUserPreferenceRequest::set_exclude_tag(int index, const char* value, size_t size) {
  exclude_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserPreferenceRequest::add_exclude_tag() {
  return exclude_tag_.Add();
}
inline void GetUserPreferenceRequest::add_exclude_tag(const ::std::string& value) {
  exclude_tag_.Add()->assign(value);
}
inline void GetUserPreferenceRequest::add_exclude_tag(const char* value) {
  exclude_tag_.Add()->assign(value);
}
inline void GetUserPreferenceRequest::add_exclude_tag(const char* value, size_t size) {
  exclude_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUserPreferenceRequest::exclude_tag() const {
  return exclude_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUserPreferenceRequest::mutable_exclude_tag() {
  return &exclude_tag_;
}

// -------------------------------------------------------------------

// GetUserPreferenceResponse

// repeated .lbs.da.openservice.UserPreference values = 1;
inline int GetUserPreferenceResponse::values_size() const {
  return values_.size();
}
inline void GetUserPreferenceResponse::clear_values() {
  values_.Clear();
}
inline const ::lbs::da::openservice::UserPreference& GetUserPreferenceResponse::values(int index) const {
  return values_.Get(index);
}
inline ::lbs::da::openservice::UserPreference* GetUserPreferenceResponse::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::lbs::da::openservice::UserPreference* GetUserPreferenceResponse::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::UserPreference >&
GetUserPreferenceResponse::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::UserPreference >*
GetUserPreferenceResponse::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// RegularStayPoint

// required .lbs.da.openservice.UserTrajStatus type = 1;
inline bool RegularStayPoint::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegularStayPoint::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegularStayPoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegularStayPoint::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline lbs::da::openservice::UserTrajStatus RegularStayPoint::type() const {
  return static_cast< lbs::da::openservice::UserTrajStatus >(type_);
}
inline void RegularStayPoint::set_type(lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  set_has_type();
  type_ = value;
}

// required double longitude = 2;
inline bool RegularStayPoint::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegularStayPoint::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegularStayPoint::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegularStayPoint::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double RegularStayPoint::longitude() const {
  return longitude_;
}
inline void RegularStayPoint::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// required double latitude = 3;
inline bool RegularStayPoint::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegularStayPoint::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegularStayPoint::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegularStayPoint::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double RegularStayPoint::latitude() const {
  return latitude_;
}
inline void RegularStayPoint::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double radius = 4;
inline bool RegularStayPoint::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegularStayPoint::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegularStayPoint::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegularStayPoint::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double RegularStayPoint::radius() const {
  return radius_;
}
inline void RegularStayPoint::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// optional int32 areaid = 5;
inline bool RegularStayPoint::has_areaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegularStayPoint::set_has_areaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegularStayPoint::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegularStayPoint::clear_areaid() {
  areaid_ = 0;
  clear_has_areaid();
}
inline ::google::protobuf::int32 RegularStayPoint::areaid() const {
  return areaid_;
}
inline void RegularStayPoint::set_areaid(::google::protobuf::int32 value) {
  set_has_areaid();
  areaid_ = value;
}

// -------------------------------------------------------------------

// GetRegularStayPointRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetRegularStayPointRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRegularStayPointRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRegularStayPointRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRegularStayPointRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetRegularStayPointRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetRegularStayPointRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetRegularStayPointRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required string cuid = 2;
inline bool GetRegularStayPointRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRegularStayPointRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRegularStayPointRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRegularStayPointRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetRegularStayPointRequest::cuid() const {
  return *cuid_;
}
inline void GetRegularStayPointRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetRegularStayPointRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetRegularStayPointRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRegularStayPointRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetRegularStayPointRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.UserTrajStatus type = 3;
inline int GetRegularStayPointRequest::type_size() const {
  return type_.size();
}
inline void GetRegularStayPointRequest::clear_type() {
  type_.Clear();
}
inline lbs::da::openservice::UserTrajStatus GetRegularStayPointRequest::type(int index) const {
  return static_cast< lbs::da::openservice::UserTrajStatus >(type_.Get(index));
}
inline void GetRegularStayPointRequest::set_type(int index, lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  type_.Set(index, value);
}
inline void GetRegularStayPointRequest::add_type(lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GetRegularStayPointRequest::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
GetRegularStayPointRequest::mutable_type() {
  return &type_;
}

// -------------------------------------------------------------------

// GetRegularStayPointResponse

// repeated .lbs.da.openservice.RegularStayPoint value = 1;
inline int GetRegularStayPointResponse::value_size() const {
  return value_.size();
}
inline void GetRegularStayPointResponse::clear_value() {
  value_.Clear();
}
inline const ::lbs::da::openservice::RegularStayPoint& GetRegularStayPointResponse::value(int index) const {
  return value_.Get(index);
}
inline ::lbs::da::openservice::RegularStayPoint* GetRegularStayPointResponse::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::lbs::da::openservice::RegularStayPoint* GetRegularStayPointResponse::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegularStayPoint >&
GetRegularStayPointResponse::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegularStayPoint >*
GetRegularStayPointResponse::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Item

// required string id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Item::id() const {
  return *id_;
}
inline void Item::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Item::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Item::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Item::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated double value = 2;
inline int Item::value_size() const {
  return value_.size();
}
inline void Item::clear_value() {
  value_.Clear();
}
inline double Item::value(int index) const {
  return value_.Get(index);
}
inline void Item::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void Item::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Item::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
Item::mutable_value() {
  return &value_;
}

// repeated string str_value = 3;
inline int Item::str_value_size() const {
  return str_value_.size();
}
inline void Item::clear_str_value() {
  str_value_.Clear();
}
inline const ::std::string& Item::str_value(int index) const {
  return str_value_.Get(index);
}
inline ::std::string* Item::mutable_str_value(int index) {
  return str_value_.Mutable(index);
}
inline void Item::set_str_value(int index, const ::std::string& value) {
  str_value_.Mutable(index)->assign(value);
}
inline void Item::set_str_value(int index, const char* value) {
  str_value_.Mutable(index)->assign(value);
}
inline void Item::set_str_value(int index, const char* value, size_t size) {
  str_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::add_str_value() {
  return str_value_.Add();
}
inline void Item::add_str_value(const ::std::string& value) {
  str_value_.Add()->assign(value);
}
inline void Item::add_str_value(const char* value) {
  str_value_.Add()->assign(value);
}
inline void Item::add_str_value(const char* value, size_t size) {
  str_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Item::str_value() const {
  return str_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Item::mutable_str_value() {
  return &str_value_;
}

// -------------------------------------------------------------------

// ItemBytes

// required string id = 1;
inline bool ItemBytes::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemBytes::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemBytes::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemBytes::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ItemBytes::id() const {
  return *id_;
}
inline void ItemBytes::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ItemBytes::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ItemBytes::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemBytes::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ItemBytes::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated double value = 2;
inline int ItemBytes::value_size() const {
  return value_.size();
}
inline void ItemBytes::clear_value() {
  value_.Clear();
}
inline double ItemBytes::value(int index) const {
  return value_.Get(index);
}
inline void ItemBytes::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void ItemBytes::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ItemBytes::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
ItemBytes::mutable_value() {
  return &value_;
}

// repeated bytes str_value = 3;
inline int ItemBytes::str_value_size() const {
  return str_value_.size();
}
inline void ItemBytes::clear_str_value() {
  str_value_.Clear();
}
inline const ::std::string& ItemBytes::str_value(int index) const {
  return str_value_.Get(index);
}
inline ::std::string* ItemBytes::mutable_str_value(int index) {
  return str_value_.Mutable(index);
}
inline void ItemBytes::set_str_value(int index, const ::std::string& value) {
  str_value_.Mutable(index)->assign(value);
}
inline void ItemBytes::set_str_value(int index, const char* value) {
  str_value_.Mutable(index)->assign(value);
}
inline void ItemBytes::set_str_value(int index, const void* value, size_t size) {
  str_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemBytes::add_str_value() {
  return str_value_.Add();
}
inline void ItemBytes::add_str_value(const ::std::string& value) {
  str_value_.Add()->assign(value);
}
inline void ItemBytes::add_str_value(const char* value) {
  str_value_.Add()->assign(value);
}
inline void ItemBytes::add_str_value(const void* value, size_t size) {
  str_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ItemBytes::str_value() const {
  return str_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ItemBytes::mutable_str_value() {
  return &str_value_;
}

// -------------------------------------------------------------------

// GetItemsByItemRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetItemsByItemRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetItemsByItemRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetItemsByItemRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetItemsByItemRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetItemsByItemRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetItemsByItemRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetItemsByItemRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional string algorithmId = 2;
inline bool GetItemsByItemRequest::has_algorithmid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetItemsByItemRequest::set_has_algorithmid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetItemsByItemRequest::clear_has_algorithmid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetItemsByItemRequest::clear_algorithmid() {
  if (algorithmid_ != &::google::protobuf::internal::kEmptyString) {
    algorithmid_->clear();
  }
  clear_has_algorithmid();
}
inline const ::std::string& GetItemsByItemRequest::algorithmid() const {
  return *algorithmid_;
}
inline void GetItemsByItemRequest::set_algorithmid(const ::std::string& value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetItemsByItemRequest::set_algorithmid(const char* value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetItemsByItemRequest::set_algorithmid(const char* value, size_t size) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemRequest::mutable_algorithmid() {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  return algorithmid_;
}
inline ::std::string* GetItemsByItemRequest::release_algorithmid() {
  clear_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = algorithmid_;
    algorithmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string item_ids = 3;
inline int GetItemsByItemRequest::item_ids_size() const {
  return item_ids_.size();
}
inline void GetItemsByItemRequest::clear_item_ids() {
  item_ids_.Clear();
}
inline const ::std::string& GetItemsByItemRequest::item_ids(int index) const {
  return item_ids_.Get(index);
}
inline ::std::string* GetItemsByItemRequest::mutable_item_ids(int index) {
  return item_ids_.Mutable(index);
}
inline void GetItemsByItemRequest::set_item_ids(int index, const ::std::string& value) {
  item_ids_.Mutable(index)->assign(value);
}
inline void GetItemsByItemRequest::set_item_ids(int index, const char* value) {
  item_ids_.Mutable(index)->assign(value);
}
inline void GetItemsByItemRequest::set_item_ids(int index, const char* value, size_t size) {
  item_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemRequest::add_item_ids() {
  return item_ids_.Add();
}
inline void GetItemsByItemRequest::add_item_ids(const ::std::string& value) {
  item_ids_.Add()->assign(value);
}
inline void GetItemsByItemRequest::add_item_ids(const char* value) {
  item_ids_.Add()->assign(value);
}
inline void GetItemsByItemRequest::add_item_ids(const char* value, size_t size) {
  item_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetItemsByItemRequest::item_ids() const {
  return item_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetItemsByItemRequest::mutable_item_ids() {
  return &item_ids_;
}

// optional string userid = 4;
inline bool GetItemsByItemRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetItemsByItemRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetItemsByItemRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetItemsByItemRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GetItemsByItemRequest::userid() const {
  return *userid_;
}
inline void GetItemsByItemRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetItemsByItemRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetItemsByItemRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GetItemsByItemRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string useridtype = 5;
inline bool GetItemsByItemRequest::has_useridtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetItemsByItemRequest::set_has_useridtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetItemsByItemRequest::clear_has_useridtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetItemsByItemRequest::clear_useridtype() {
  if (useridtype_ != &::google::protobuf::internal::kEmptyString) {
    useridtype_->clear();
  }
  clear_has_useridtype();
}
inline const ::std::string& GetItemsByItemRequest::useridtype() const {
  return *useridtype_;
}
inline void GetItemsByItemRequest::set_useridtype(const ::std::string& value) {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  useridtype_->assign(value);
}
inline void GetItemsByItemRequest::set_useridtype(const char* value) {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  useridtype_->assign(value);
}
inline void GetItemsByItemRequest::set_useridtype(const char* value, size_t size) {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  useridtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemRequest::mutable_useridtype() {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  return useridtype_;
}
inline ::std::string* GetItemsByItemRequest::release_useridtype() {
  clear_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = useridtype_;
    useridtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 limit = 6;
inline bool GetItemsByItemRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetItemsByItemRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetItemsByItemRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetItemsByItemRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 GetItemsByItemRequest::limit() const {
  return limit_;
}
inline void GetItemsByItemRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// repeated .lbs.da.openservice.Arg args = 7;
inline int GetItemsByItemRequest::args_size() const {
  return args_.size();
}
inline void GetItemsByItemRequest::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& GetItemsByItemRequest::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* GetItemsByItemRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* GetItemsByItemRequest::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
GetItemsByItemRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
GetItemsByItemRequest::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// GetItemsByItemResponse

// repeated .lbs.da.openservice.Item items = 1;
inline int GetItemsByItemResponse::items_size() const {
  return items_.size();
}
inline void GetItemsByItemResponse::clear_items() {
  items_.Clear();
}
inline const ::lbs::da::openservice::Item& GetItemsByItemResponse::items(int index) const {
  return items_.Get(index);
}
inline ::lbs::da::openservice::Item* GetItemsByItemResponse::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::lbs::da::openservice::Item* GetItemsByItemResponse::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Item >&
GetItemsByItemResponse::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Item >*
GetItemsByItemResponse::mutable_items() {
  return &items_;
}

// optional string userid = 2;
inline bool GetItemsByItemResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetItemsByItemResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetItemsByItemResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetItemsByItemResponse::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GetItemsByItemResponse::userid() const {
  return *userid_;
}
inline void GetItemsByItemResponse::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetItemsByItemResponse::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetItemsByItemResponse::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemResponse::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GetItemsByItemResponse::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string algorithmId = 3;
inline bool GetItemsByItemResponse::has_algorithmid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetItemsByItemResponse::set_has_algorithmid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetItemsByItemResponse::clear_has_algorithmid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetItemsByItemResponse::clear_algorithmid() {
  if (algorithmid_ != &::google::protobuf::internal::kEmptyString) {
    algorithmid_->clear();
  }
  clear_has_algorithmid();
}
inline const ::std::string& GetItemsByItemResponse::algorithmid() const {
  return *algorithmid_;
}
inline void GetItemsByItemResponse::set_algorithmid(const ::std::string& value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetItemsByItemResponse::set_algorithmid(const char* value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetItemsByItemResponse::set_algorithmid(const char* value, size_t size) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemResponse::mutable_algorithmid() {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  return algorithmid_;
}
inline ::std::string* GetItemsByItemResponse::release_algorithmid() {
  clear_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = algorithmid_;
    algorithmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uniqId = 4;
inline bool GetItemsByItemResponse::has_uniqid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetItemsByItemResponse::set_has_uniqid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetItemsByItemResponse::clear_has_uniqid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetItemsByItemResponse::clear_uniqid() {
  if (uniqid_ != &::google::protobuf::internal::kEmptyString) {
    uniqid_->clear();
  }
  clear_has_uniqid();
}
inline const ::std::string& GetItemsByItemResponse::uniqid() const {
  return *uniqid_;
}
inline void GetItemsByItemResponse::set_uniqid(const ::std::string& value) {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  uniqid_->assign(value);
}
inline void GetItemsByItemResponse::set_uniqid(const char* value) {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  uniqid_->assign(value);
}
inline void GetItemsByItemResponse::set_uniqid(const char* value, size_t size) {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  uniqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemResponse::mutable_uniqid() {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  return uniqid_;
}
inline ::std::string* GetItemsByItemResponse::release_uniqid() {
  clear_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqid_;
    uniqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string bid = 5;
inline bool GetItemsByItemResponse::has_bid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetItemsByItemResponse::set_has_bid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetItemsByItemResponse::clear_has_bid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetItemsByItemResponse::clear_bid() {
  if (bid_ != &::google::protobuf::internal::kEmptyString) {
    bid_->clear();
  }
  clear_has_bid();
}
inline const ::std::string& GetItemsByItemResponse::bid() const {
  return *bid_;
}
inline void GetItemsByItemResponse::set_bid(const ::std::string& value) {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  bid_->assign(value);
}
inline void GetItemsByItemResponse::set_bid(const char* value) {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  bid_->assign(value);
}
inline void GetItemsByItemResponse::set_bid(const char* value, size_t size) {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  bid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetItemsByItemResponse::mutable_bid() {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  return bid_;
}
inline ::std::string* GetItemsByItemResponse::release_bid() {
  clear_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bid_;
    bid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg args = 6;
inline int GetItemsByItemResponse::args_size() const {
  return args_.size();
}
inline void GetItemsByItemResponse::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& GetItemsByItemResponse::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* GetItemsByItemResponse::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* GetItemsByItemResponse::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
GetItemsByItemResponse::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
GetItemsByItemResponse::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// GetBNItemsRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetBNItemsRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBNItemsRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBNItemsRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBNItemsRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetBNItemsRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetBNItemsRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetBNItemsRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional bytes algorithmId = 2;
inline bool GetBNItemsRequest::has_algorithmid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBNItemsRequest::set_has_algorithmid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBNItemsRequest::clear_has_algorithmid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBNItemsRequest::clear_algorithmid() {
  if (algorithmid_ != &::google::protobuf::internal::kEmptyString) {
    algorithmid_->clear();
  }
  clear_has_algorithmid();
}
inline const ::std::string& GetBNItemsRequest::algorithmid() const {
  return *algorithmid_;
}
inline void GetBNItemsRequest::set_algorithmid(const ::std::string& value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetBNItemsRequest::set_algorithmid(const char* value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetBNItemsRequest::set_algorithmid(const void* value, size_t size) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_algorithmid() {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  return algorithmid_;
}
inline ::std::string* GetBNItemsRequest::release_algorithmid() {
  clear_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = algorithmid_;
    algorithmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 limit = 3;
inline bool GetBNItemsRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBNItemsRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBNItemsRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBNItemsRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 GetBNItemsRequest::limit() const {
  return limit_;
}
inline void GetBNItemsRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 source = 4;
inline bool GetBNItemsRequest::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetBNItemsRequest::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetBNItemsRequest::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetBNItemsRequest::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 GetBNItemsRequest::source() const {
  return source_;
}
inline void GetBNItemsRequest::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
}

// optional bytes userid = 5;
inline bool GetBNItemsRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetBNItemsRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetBNItemsRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetBNItemsRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GetBNItemsRequest::userid() const {
  return *userid_;
}
inline void GetBNItemsRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetBNItemsRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetBNItemsRequest::set_userid(const void* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GetBNItemsRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes cuid = 6;
inline bool GetBNItemsRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetBNItemsRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetBNItemsRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetBNItemsRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetBNItemsRequest::cuid() const {
  return *cuid_;
}
inline void GetBNItemsRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetBNItemsRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetBNItemsRequest::set_cuid(const void* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetBNItemsRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes baidu_id = 7;
inline bool GetBNItemsRequest::has_baidu_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetBNItemsRequest::set_has_baidu_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetBNItemsRequest::clear_has_baidu_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetBNItemsRequest::clear_baidu_id() {
  if (baidu_id_ != &::google::protobuf::internal::kEmptyString) {
    baidu_id_->clear();
  }
  clear_has_baidu_id();
}
inline const ::std::string& GetBNItemsRequest::baidu_id() const {
  return *baidu_id_;
}
inline void GetBNItemsRequest::set_baidu_id(const ::std::string& value) {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  baidu_id_->assign(value);
}
inline void GetBNItemsRequest::set_baidu_id(const char* value) {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  baidu_id_->assign(value);
}
inline void GetBNItemsRequest::set_baidu_id(const void* value, size_t size) {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  baidu_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_baidu_id() {
  set_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    baidu_id_ = new ::std::string;
  }
  return baidu_id_;
}
inline ::std::string* GetBNItemsRequest::release_baidu_id() {
  clear_has_baidu_id();
  if (baidu_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = baidu_id_;
    baidu_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes nm_key = 8;
inline bool GetBNItemsRequest::has_nm_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetBNItemsRequest::set_has_nm_key() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetBNItemsRequest::clear_has_nm_key() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetBNItemsRequest::clear_nm_key() {
  if (nm_key_ != &::google::protobuf::internal::kEmptyString) {
    nm_key_->clear();
  }
  clear_has_nm_key();
}
inline const ::std::string& GetBNItemsRequest::nm_key() const {
  return *nm_key_;
}
inline void GetBNItemsRequest::set_nm_key(const ::std::string& value) {
  set_has_nm_key();
  if (nm_key_ == &::google::protobuf::internal::kEmptyString) {
    nm_key_ = new ::std::string;
  }
  nm_key_->assign(value);
}
inline void GetBNItemsRequest::set_nm_key(const char* value) {
  set_has_nm_key();
  if (nm_key_ == &::google::protobuf::internal::kEmptyString) {
    nm_key_ = new ::std::string;
  }
  nm_key_->assign(value);
}
inline void GetBNItemsRequest::set_nm_key(const void* value, size_t size) {
  set_has_nm_key();
  if (nm_key_ == &::google::protobuf::internal::kEmptyString) {
    nm_key_ = new ::std::string;
  }
  nm_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_nm_key() {
  set_has_nm_key();
  if (nm_key_ == &::google::protobuf::internal::kEmptyString) {
    nm_key_ = new ::std::string;
  }
  return nm_key_;
}
inline ::std::string* GetBNItemsRequest::release_nm_key() {
  clear_has_nm_key();
  if (nm_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nm_key_;
    nm_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes useridtype = 9;
inline bool GetBNItemsRequest::has_useridtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetBNItemsRequest::set_has_useridtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetBNItemsRequest::clear_has_useridtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetBNItemsRequest::clear_useridtype() {
  if (useridtype_ != &::google::protobuf::internal::kEmptyString) {
    useridtype_->clear();
  }
  clear_has_useridtype();
}
inline const ::std::string& GetBNItemsRequest::useridtype() const {
  return *useridtype_;
}
inline void GetBNItemsRequest::set_useridtype(const ::std::string& value) {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  useridtype_->assign(value);
}
inline void GetBNItemsRequest::set_useridtype(const char* value) {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  useridtype_->assign(value);
}
inline void GetBNItemsRequest::set_useridtype(const void* value, size_t size) {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  useridtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_useridtype() {
  set_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    useridtype_ = new ::std::string;
  }
  return useridtype_;
}
inline ::std::string* GetBNItemsRequest::release_useridtype() {
  clear_has_useridtype();
  if (useridtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = useridtype_;
    useridtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes coor_sys = 10;
inline bool GetBNItemsRequest::has_coor_sys() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetBNItemsRequest::set_has_coor_sys() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetBNItemsRequest::clear_has_coor_sys() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetBNItemsRequest::clear_coor_sys() {
  if (coor_sys_ != &::google::protobuf::internal::kEmptyString) {
    coor_sys_->clear();
  }
  clear_has_coor_sys();
}
inline const ::std::string& GetBNItemsRequest::coor_sys() const {
  return *coor_sys_;
}
inline void GetBNItemsRequest::set_coor_sys(const ::std::string& value) {
  set_has_coor_sys();
  if (coor_sys_ == &::google::protobuf::internal::kEmptyString) {
    coor_sys_ = new ::std::string;
  }
  coor_sys_->assign(value);
}
inline void GetBNItemsRequest::set_coor_sys(const char* value) {
  set_has_coor_sys();
  if (coor_sys_ == &::google::protobuf::internal::kEmptyString) {
    coor_sys_ = new ::std::string;
  }
  coor_sys_->assign(value);
}
inline void GetBNItemsRequest::set_coor_sys(const void* value, size_t size) {
  set_has_coor_sys();
  if (coor_sys_ == &::google::protobuf::internal::kEmptyString) {
    coor_sys_ = new ::std::string;
  }
  coor_sys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_coor_sys() {
  set_has_coor_sys();
  if (coor_sys_ == &::google::protobuf::internal::kEmptyString) {
    coor_sys_ = new ::std::string;
  }
  return coor_sys_;
}
inline ::std::string* GetBNItemsRequest::release_coor_sys() {
  clear_has_coor_sys();
  if (coor_sys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coor_sys_;
    coor_sys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float x = 11;
inline bool GetBNItemsRequest::has_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetBNItemsRequest::set_has_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetBNItemsRequest::clear_has_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetBNItemsRequest::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GetBNItemsRequest::x() const {
  return x_;
}
inline void GetBNItemsRequest::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 12;
inline bool GetBNItemsRequest::has_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetBNItemsRequest::set_has_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetBNItemsRequest::clear_has_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetBNItemsRequest::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float GetBNItemsRequest::y() const {
  return y_;
}
inline void GetBNItemsRequest::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional int64 area_id = 13;
inline bool GetBNItemsRequest::has_area_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GetBNItemsRequest::set_has_area_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GetBNItemsRequest::clear_has_area_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GetBNItemsRequest::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
  clear_has_area_id();
}
inline ::google::protobuf::int64 GetBNItemsRequest::area_id() const {
  return area_id_;
}
inline void GetBNItemsRequest::set_area_id(::google::protobuf::int64 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional bytes query = 14;
inline bool GetBNItemsRequest::has_query() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GetBNItemsRequest::set_has_query() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GetBNItemsRequest::clear_has_query() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GetBNItemsRequest::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& GetBNItemsRequest::query() const {
  return *query_;
}
inline void GetBNItemsRequest::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void GetBNItemsRequest::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void GetBNItemsRequest::set_query(const void* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* GetBNItemsRequest::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int64 vec_catg = 15;
inline int GetBNItemsRequest::vec_catg_size() const {
  return vec_catg_.size();
}
inline void GetBNItemsRequest::clear_vec_catg() {
  vec_catg_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::vec_catg(int index) const {
  return vec_catg_.Get(index);
}
inline void GetBNItemsRequest::set_vec_catg(int index, ::google::protobuf::int64 value) {
  vec_catg_.Set(index, value);
}
inline void GetBNItemsRequest::add_vec_catg(::google::protobuf::int64 value) {
  vec_catg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::vec_catg() const {
  return vec_catg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_vec_catg() {
  return &vec_catg_;
}

// repeated int64 vec_subcatg = 16;
inline int GetBNItemsRequest::vec_subcatg_size() const {
  return vec_subcatg_.size();
}
inline void GetBNItemsRequest::clear_vec_subcatg() {
  vec_subcatg_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::vec_subcatg(int index) const {
  return vec_subcatg_.Get(index);
}
inline void GetBNItemsRequest::set_vec_subcatg(int index, ::google::protobuf::int64 value) {
  vec_subcatg_.Set(index, value);
}
inline void GetBNItemsRequest::add_vec_subcatg(::google::protobuf::int64 value) {
  vec_subcatg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::vec_subcatg() const {
  return vec_subcatg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_vec_subcatg() {
  return &vec_subcatg_;
}

// repeated int64 vec_thdcatg = 17;
inline int GetBNItemsRequest::vec_thdcatg_size() const {
  return vec_thdcatg_.size();
}
inline void GetBNItemsRequest::clear_vec_thdcatg() {
  vec_thdcatg_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::vec_thdcatg(int index) const {
  return vec_thdcatg_.Get(index);
}
inline void GetBNItemsRequest::set_vec_thdcatg(int index, ::google::protobuf::int64 value) {
  vec_thdcatg_.Set(index, value);
}
inline void GetBNItemsRequest::add_vec_thdcatg(::google::protobuf::int64 value) {
  vec_thdcatg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::vec_thdcatg() const {
  return vec_thdcatg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_vec_thdcatg() {
  return &vec_thdcatg_;
}

// repeated int64 vec_shop_dist = 18;
inline int GetBNItemsRequest::vec_shop_dist_size() const {
  return vec_shop_dist_.size();
}
inline void GetBNItemsRequest::clear_vec_shop_dist() {
  vec_shop_dist_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::vec_shop_dist(int index) const {
  return vec_shop_dist_.Get(index);
}
inline void GetBNItemsRequest::set_vec_shop_dist(int index, ::google::protobuf::int64 value) {
  vec_shop_dist_.Set(index, value);
}
inline void GetBNItemsRequest::add_vec_shop_dist(::google::protobuf::int64 value) {
  vec_shop_dist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::vec_shop_dist() const {
  return vec_shop_dist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_vec_shop_dist() {
  return &vec_shop_dist_;
}

// repeated int64 vec_shop_range = 19;
inline int GetBNItemsRequest::vec_shop_range_size() const {
  return vec_shop_range_.size();
}
inline void GetBNItemsRequest::clear_vec_shop_range() {
  vec_shop_range_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::vec_shop_range(int index) const {
  return vec_shop_range_.Get(index);
}
inline void GetBNItemsRequest::set_vec_shop_range(int index, ::google::protobuf::int64 value) {
  vec_shop_range_.Set(index, value);
}
inline void GetBNItemsRequest::add_vec_shop_range(::google::protobuf::int64 value) {
  vec_shop_range_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::vec_shop_range() const {
  return vec_shop_range_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_vec_shop_range() {
  return &vec_shop_range_;
}

// repeated bytes item_ids = 20;
inline int GetBNItemsRequest::item_ids_size() const {
  return item_ids_.size();
}
inline void GetBNItemsRequest::clear_item_ids() {
  item_ids_.Clear();
}
inline const ::std::string& GetBNItemsRequest::item_ids(int index) const {
  return item_ids_.Get(index);
}
inline ::std::string* GetBNItemsRequest::mutable_item_ids(int index) {
  return item_ids_.Mutable(index);
}
inline void GetBNItemsRequest::set_item_ids(int index, const ::std::string& value) {
  item_ids_.Mutable(index)->assign(value);
}
inline void GetBNItemsRequest::set_item_ids(int index, const char* value) {
  item_ids_.Mutable(index)->assign(value);
}
inline void GetBNItemsRequest::set_item_ids(int index, const void* value, size_t size) {
  item_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsRequest::add_item_ids() {
  return item_ids_.Add();
}
inline void GetBNItemsRequest::add_item_ids(const ::std::string& value) {
  item_ids_.Add()->assign(value);
}
inline void GetBNItemsRequest::add_item_ids(const char* value) {
  item_ids_.Add()->assign(value);
}
inline void GetBNItemsRequest::add_item_ids(const void* value, size_t size) {
  item_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetBNItemsRequest::item_ids() const {
  return item_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetBNItemsRequest::mutable_item_ids() {
  return &item_ids_;
}

// optional int32 item_id_format = 21;
inline bool GetBNItemsRequest::has_item_id_format() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GetBNItemsRequest::set_has_item_id_format() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GetBNItemsRequest::clear_has_item_id_format() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GetBNItemsRequest::clear_item_id_format() {
  item_id_format_ = 0;
  clear_has_item_id_format();
}
inline ::google::protobuf::int32 GetBNItemsRequest::item_id_format() const {
  return item_id_format_;
}
inline void GetBNItemsRequest::set_item_id_format(::google::protobuf::int32 value) {
  set_has_item_id_format();
  item_id_format_ = value;
}

// repeated int64 qrw_vec_brand_id = 22;
inline int GetBNItemsRequest::qrw_vec_brand_id_size() const {
  return qrw_vec_brand_id_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_brand_id() {
  qrw_vec_brand_id_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_brand_id(int index) const {
  return qrw_vec_brand_id_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_brand_id(int index, ::google::protobuf::int64 value) {
  qrw_vec_brand_id_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_brand_id(::google::protobuf::int64 value) {
  qrw_vec_brand_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_brand_id() const {
  return qrw_vec_brand_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_brand_id() {
  return &qrw_vec_brand_id_;
}

// repeated int64 qrw_vec_thdcatg = 23;
inline int GetBNItemsRequest::qrw_vec_thdcatg_size() const {
  return qrw_vec_thdcatg_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_thdcatg() {
  qrw_vec_thdcatg_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_thdcatg(int index) const {
  return qrw_vec_thdcatg_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_thdcatg(int index, ::google::protobuf::int64 value) {
  qrw_vec_thdcatg_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_thdcatg(::google::protobuf::int64 value) {
  qrw_vec_thdcatg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_thdcatg() const {
  return qrw_vec_thdcatg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_thdcatg() {
  return &qrw_vec_thdcatg_;
}

// repeated int64 qrw_vec_subcatg = 24;
inline int GetBNItemsRequest::qrw_vec_subcatg_size() const {
  return qrw_vec_subcatg_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_subcatg() {
  qrw_vec_subcatg_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_subcatg(int index) const {
  return qrw_vec_subcatg_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_subcatg(int index, ::google::protobuf::int64 value) {
  qrw_vec_subcatg_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_subcatg(::google::protobuf::int64 value) {
  qrw_vec_subcatg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_subcatg() const {
  return qrw_vec_subcatg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_subcatg() {
  return &qrw_vec_subcatg_;
}

// repeated int64 qrw_vec_catg = 25;
inline int GetBNItemsRequest::qrw_vec_catg_size() const {
  return qrw_vec_catg_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_catg() {
  qrw_vec_catg_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_catg(int index) const {
  return qrw_vec_catg_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_catg(int index, ::google::protobuf::int64 value) {
  qrw_vec_catg_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_catg(::google::protobuf::int64 value) {
  qrw_vec_catg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_catg() const {
  return qrw_vec_catg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_catg() {
  return &qrw_vec_catg_;
}

// repeated int64 qrw_vec_shop_city = 26;
inline int GetBNItemsRequest::qrw_vec_shop_city_size() const {
  return qrw_vec_shop_city_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_shop_city() {
  qrw_vec_shop_city_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_shop_city(int index) const {
  return qrw_vec_shop_city_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_shop_city(int index, ::google::protobuf::int64 value) {
  qrw_vec_shop_city_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_shop_city(::google::protobuf::int64 value) {
  qrw_vec_shop_city_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_shop_city() const {
  return qrw_vec_shop_city_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_shop_city() {
  return &qrw_vec_shop_city_;
}

// repeated int64 qrw_vec_shop_dist = 27;
inline int GetBNItemsRequest::qrw_vec_shop_dist_size() const {
  return qrw_vec_shop_dist_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_shop_dist() {
  qrw_vec_shop_dist_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_shop_dist(int index) const {
  return qrw_vec_shop_dist_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_shop_dist(int index, ::google::protobuf::int64 value) {
  qrw_vec_shop_dist_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_shop_dist(::google::protobuf::int64 value) {
  qrw_vec_shop_dist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_shop_dist() const {
  return qrw_vec_shop_dist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_shop_dist() {
  return &qrw_vec_shop_dist_;
}

// repeated int64 qrw_vec_shop_range = 28;
inline int GetBNItemsRequest::qrw_vec_shop_range_size() const {
  return qrw_vec_shop_range_.size();
}
inline void GetBNItemsRequest::clear_qrw_vec_shop_range() {
  qrw_vec_shop_range_.Clear();
}
inline ::google::protobuf::int64 GetBNItemsRequest::qrw_vec_shop_range(int index) const {
  return qrw_vec_shop_range_.Get(index);
}
inline void GetBNItemsRequest::set_qrw_vec_shop_range(int index, ::google::protobuf::int64 value) {
  qrw_vec_shop_range_.Set(index, value);
}
inline void GetBNItemsRequest::add_qrw_vec_shop_range(::google::protobuf::int64 value) {
  qrw_vec_shop_range_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetBNItemsRequest::qrw_vec_shop_range() const {
  return qrw_vec_shop_range_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetBNItemsRequest::mutable_qrw_vec_shop_range() {
  return &qrw_vec_shop_range_;
}

// repeated .lbs.da.openservice.Arg args = 29;
inline int GetBNItemsRequest::args_size() const {
  return args_.size();
}
inline void GetBNItemsRequest::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& GetBNItemsRequest::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* GetBNItemsRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* GetBNItemsRequest::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
GetBNItemsRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
GetBNItemsRequest::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// GetBNItemsResponse

// repeated .lbs.da.openservice.ItemBytes items = 1;
inline int GetBNItemsResponse::items_size() const {
  return items_.size();
}
inline void GetBNItemsResponse::clear_items() {
  items_.Clear();
}
inline const ::lbs::da::openservice::ItemBytes& GetBNItemsResponse::items(int index) const {
  return items_.Get(index);
}
inline ::lbs::da::openservice::ItemBytes* GetBNItemsResponse::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::lbs::da::openservice::ItemBytes* GetBNItemsResponse::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemBytes >&
GetBNItemsResponse::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemBytes >*
GetBNItemsResponse::mutable_items() {
  return &items_;
}

// optional bytes userid = 2;
inline bool GetBNItemsResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBNItemsResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBNItemsResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBNItemsResponse::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GetBNItemsResponse::userid() const {
  return *userid_;
}
inline void GetBNItemsResponse::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetBNItemsResponse::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetBNItemsResponse::set_userid(const void* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsResponse::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GetBNItemsResponse::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes algorithmId = 3;
inline bool GetBNItemsResponse::has_algorithmid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetBNItemsResponse::set_has_algorithmid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetBNItemsResponse::clear_has_algorithmid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetBNItemsResponse::clear_algorithmid() {
  if (algorithmid_ != &::google::protobuf::internal::kEmptyString) {
    algorithmid_->clear();
  }
  clear_has_algorithmid();
}
inline const ::std::string& GetBNItemsResponse::algorithmid() const {
  return *algorithmid_;
}
inline void GetBNItemsResponse::set_algorithmid(const ::std::string& value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetBNItemsResponse::set_algorithmid(const char* value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void GetBNItemsResponse::set_algorithmid(const void* value, size_t size) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsResponse::mutable_algorithmid() {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  return algorithmid_;
}
inline ::std::string* GetBNItemsResponse::release_algorithmid() {
  clear_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = algorithmid_;
    algorithmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes uniqId = 4;
inline bool GetBNItemsResponse::has_uniqid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetBNItemsResponse::set_has_uniqid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetBNItemsResponse::clear_has_uniqid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetBNItemsResponse::clear_uniqid() {
  if (uniqid_ != &::google::protobuf::internal::kEmptyString) {
    uniqid_->clear();
  }
  clear_has_uniqid();
}
inline const ::std::string& GetBNItemsResponse::uniqid() const {
  return *uniqid_;
}
inline void GetBNItemsResponse::set_uniqid(const ::std::string& value) {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  uniqid_->assign(value);
}
inline void GetBNItemsResponse::set_uniqid(const char* value) {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  uniqid_->assign(value);
}
inline void GetBNItemsResponse::set_uniqid(const void* value, size_t size) {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  uniqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsResponse::mutable_uniqid() {
  set_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    uniqid_ = new ::std::string;
  }
  return uniqid_;
}
inline ::std::string* GetBNItemsResponse::release_uniqid() {
  clear_has_uniqid();
  if (uniqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqid_;
    uniqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes bid = 5;
inline bool GetBNItemsResponse::has_bid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetBNItemsResponse::set_has_bid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetBNItemsResponse::clear_has_bid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetBNItemsResponse::clear_bid() {
  if (bid_ != &::google::protobuf::internal::kEmptyString) {
    bid_->clear();
  }
  clear_has_bid();
}
inline const ::std::string& GetBNItemsResponse::bid() const {
  return *bid_;
}
inline void GetBNItemsResponse::set_bid(const ::std::string& value) {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  bid_->assign(value);
}
inline void GetBNItemsResponse::set_bid(const char* value) {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  bid_->assign(value);
}
inline void GetBNItemsResponse::set_bid(const void* value, size_t size) {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  bid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBNItemsResponse::mutable_bid() {
  set_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    bid_ = new ::std::string;
  }
  return bid_;
}
inline ::std::string* GetBNItemsResponse::release_bid() {
  clear_has_bid();
  if (bid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bid_;
    bid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg args = 6;
inline int GetBNItemsResponse::args_size() const {
  return args_.size();
}
inline void GetBNItemsResponse::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& GetBNItemsResponse::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* GetBNItemsResponse::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* GetBNItemsResponse::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
GetBNItemsResponse::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
GetBNItemsResponse::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// GetLatestUserTrajRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetLatestUserTrajRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLatestUserTrajRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLatestUserTrajRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLatestUserTrajRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetLatestUserTrajRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetLatestUserTrajRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetLatestUserTrajRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required string cuid = 2;
inline bool GetLatestUserTrajRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLatestUserTrajRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLatestUserTrajRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLatestUserTrajRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetLatestUserTrajRequest::cuid() const {
  return *cuid_;
}
inline void GetLatestUserTrajRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetLatestUserTrajRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetLatestUserTrajRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLatestUserTrajRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetLatestUserTrajRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLatestUserTrajResponse

// optional .lbs.da.openservice.UserTrajStatus status = 1;
inline bool GetLatestUserTrajResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLatestUserTrajResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLatestUserTrajResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline lbs::da::openservice::UserTrajStatus GetLatestUserTrajResponse::status() const {
  return static_cast< lbs::da::openservice::UserTrajStatus >(status_);
}
inline void GetLatestUserTrajResponse::set_status(lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional bool is_sticked = 2;
inline bool GetLatestUserTrajResponse::has_is_sticked() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_is_sticked() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLatestUserTrajResponse::clear_has_is_sticked() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLatestUserTrajResponse::clear_is_sticked() {
  is_sticked_ = false;
  clear_has_is_sticked();
}
inline bool GetLatestUserTrajResponse::is_sticked() const {
  return is_sticked_;
}
inline void GetLatestUserTrajResponse::set_is_sticked(bool value) {
  set_has_is_sticked();
  is_sticked_ = value;
}

// optional double longitude = 3;
inline bool GetLatestUserTrajResponse::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLatestUserTrajResponse::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLatestUserTrajResponse::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GetLatestUserTrajResponse::longitude() const {
  return longitude_;
}
inline void GetLatestUserTrajResponse::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 4;
inline bool GetLatestUserTrajResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLatestUserTrajResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLatestUserTrajResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GetLatestUserTrajResponse::latitude() const {
  return latitude_;
}
inline void GetLatestUserTrajResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional int64 start_time = 5;
inline bool GetLatestUserTrajResponse::has_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLatestUserTrajResponse::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLatestUserTrajResponse::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 GetLatestUserTrajResponse::start_time() const {
  return start_time_;
}
inline void GetLatestUserTrajResponse::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int64 update_time = 6;
inline bool GetLatestUserTrajResponse::has_update_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_update_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetLatestUserTrajResponse::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetLatestUserTrajResponse::clear_update_time() {
  update_time_ = GOOGLE_LONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::int64 GetLatestUserTrajResponse::update_time() const {
  return update_time_;
}
inline void GetLatestUserTrajResponse::set_update_time(::google::protobuf::int64 value) {
  set_has_update_time();
  update_time_ = value;
}

// optional int32 staytime = 7;
inline bool GetLatestUserTrajResponse::has_staytime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetLatestUserTrajResponse::set_has_staytime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetLatestUserTrajResponse::clear_has_staytime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetLatestUserTrajResponse::clear_staytime() {
  staytime_ = 0;
  clear_has_staytime();
}
inline ::google::protobuf::int32 GetLatestUserTrajResponse::staytime() const {
  return staytime_;
}
inline void GetLatestUserTrajResponse::set_staytime(::google::protobuf::int32 value) {
  set_has_staytime();
  staytime_ = value;
}

// -------------------------------------------------------------------

// StatElement

// required string stat_key = 1;
inline bool StatElement::has_stat_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatElement::set_has_stat_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatElement::clear_has_stat_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatElement::clear_stat_key() {
  if (stat_key_ != &::google::protobuf::internal::kEmptyString) {
    stat_key_->clear();
  }
  clear_has_stat_key();
}
inline const ::std::string& StatElement::stat_key() const {
  return *stat_key_;
}
inline void StatElement::set_stat_key(const ::std::string& value) {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  stat_key_->assign(value);
}
inline void StatElement::set_stat_key(const char* value) {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  stat_key_->assign(value);
}
inline void StatElement::set_stat_key(const char* value, size_t size) {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  stat_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatElement::mutable_stat_key() {
  set_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    stat_key_ = new ::std::string;
  }
  return stat_key_;
}
inline ::std::string* StatElement::release_stat_key() {
  clear_has_stat_key();
  if (stat_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stat_key_;
    stat_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 value = 2;
inline bool StatElement::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatElement::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatElement::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatElement::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 StatElement::value() const {
  return value_;
}
inline void StatElement::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// StatReportRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool StatReportRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatReportRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatReportRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatReportRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& StatReportRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* StatReportRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* StatReportRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .lbs.da.openservice.StatElement items = 2;
inline int StatReportRequest::items_size() const {
  return items_.size();
}
inline void StatReportRequest::clear_items() {
  items_.Clear();
}
inline const ::lbs::da::openservice::StatElement& StatReportRequest::items(int index) const {
  return items_.Get(index);
}
inline ::lbs::da::openservice::StatElement* StatReportRequest::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::lbs::da::openservice::StatElement* StatReportRequest::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >&
StatReportRequest::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >*
StatReportRequest::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// StatReportResponse

// repeated .lbs.da.openservice.StatElement items = 1;
inline int StatReportResponse::items_size() const {
  return items_.size();
}
inline void StatReportResponse::clear_items() {
  items_.Clear();
}
inline const ::lbs::da::openservice::StatElement& StatReportResponse::items(int index) const {
  return items_.Get(index);
}
inline ::lbs::da::openservice::StatElement* StatReportResponse::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::lbs::da::openservice::StatElement* StatReportResponse::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >&
StatReportResponse::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StatElement >*
StatReportResponse::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// DayRoute

// repeated string lv_id = 1;
inline int DayRoute::lv_id_size() const {
  return lv_id_.size();
}
inline void DayRoute::clear_lv_id() {
  lv_id_.Clear();
}
inline const ::std::string& DayRoute::lv_id(int index) const {
  return lv_id_.Get(index);
}
inline ::std::string* DayRoute::mutable_lv_id(int index) {
  return lv_id_.Mutable(index);
}
inline void DayRoute::set_lv_id(int index, const ::std::string& value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DayRoute::set_lv_id(int index, const char* value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DayRoute::set_lv_id(int index, const char* value, size_t size) {
  lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRoute::add_lv_id() {
  return lv_id_.Add();
}
inline void DayRoute::add_lv_id(const ::std::string& value) {
  lv_id_.Add()->assign(value);
}
inline void DayRoute::add_lv_id(const char* value) {
  lv_id_.Add()->assign(value);
}
inline void DayRoute::add_lv_id(const char* value, size_t size) {
  lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRoute::lv_id() const {
  return lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRoute::mutable_lv_id() {
  return &lv_id_;
}

// optional double scene_dura_time = 2;
inline bool DayRoute::has_scene_dura_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DayRoute::set_has_scene_dura_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DayRoute::clear_has_scene_dura_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DayRoute::clear_scene_dura_time() {
  scene_dura_time_ = 0;
  clear_has_scene_dura_time();
}
inline double DayRoute::scene_dura_time() const {
  return scene_dura_time_;
}
inline void DayRoute::set_scene_dura_time(double value) {
  set_has_scene_dura_time();
  scene_dura_time_ = value;
}

// repeated string cater = 3;
inline int DayRoute::cater_size() const {
  return cater_.size();
}
inline void DayRoute::clear_cater() {
  cater_.Clear();
}
inline const ::std::string& DayRoute::cater(int index) const {
  return cater_.Get(index);
}
inline ::std::string* DayRoute::mutable_cater(int index) {
  return cater_.Mutable(index);
}
inline void DayRoute::set_cater(int index, const ::std::string& value) {
  cater_.Mutable(index)->assign(value);
}
inline void DayRoute::set_cater(int index, const char* value) {
  cater_.Mutable(index)->assign(value);
}
inline void DayRoute::set_cater(int index, const char* value, size_t size) {
  cater_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRoute::add_cater() {
  return cater_.Add();
}
inline void DayRoute::add_cater(const ::std::string& value) {
  cater_.Add()->assign(value);
}
inline void DayRoute::add_cater(const char* value) {
  cater_.Add()->assign(value);
}
inline void DayRoute::add_cater(const char* value, size_t size) {
  cater_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRoute::cater() const {
  return cater_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRoute::mutable_cater() {
  return &cater_;
}

// repeated string hotel = 4;
inline int DayRoute::hotel_size() const {
  return hotel_.size();
}
inline void DayRoute::clear_hotel() {
  hotel_.Clear();
}
inline const ::std::string& DayRoute::hotel(int index) const {
  return hotel_.Get(index);
}
inline ::std::string* DayRoute::mutable_hotel(int index) {
  return hotel_.Mutable(index);
}
inline void DayRoute::set_hotel(int index, const ::std::string& value) {
  hotel_.Mutable(index)->assign(value);
}
inline void DayRoute::set_hotel(int index, const char* value) {
  hotel_.Mutable(index)->assign(value);
}
inline void DayRoute::set_hotel(int index, const char* value, size_t size) {
  hotel_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRoute::add_hotel() {
  return hotel_.Add();
}
inline void DayRoute::add_hotel(const ::std::string& value) {
  hotel_.Add()->assign(value);
}
inline void DayRoute::add_hotel(const char* value) {
  hotel_.Add()->assign(value);
}
inline void DayRoute::add_hotel(const char* value, size_t size) {
  hotel_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRoute::hotel() const {
  return hotel_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRoute::mutable_hotel() {
  return &hotel_;
}

// -------------------------------------------------------------------

// DynamicTripPlanRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool DynamicTripPlanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicTripPlanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DynamicTripPlanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DynamicTripPlanRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& DynamicTripPlanRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* DynamicTripPlanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* DynamicTripPlanRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated string lv_id = 2;
inline int DynamicTripPlanRequest::lv_id_size() const {
  return lv_id_.size();
}
inline void DynamicTripPlanRequest::clear_lv_id() {
  lv_id_.Clear();
}
inline const ::std::string& DynamicTripPlanRequest::lv_id(int index) const {
  return lv_id_.Get(index);
}
inline ::std::string* DynamicTripPlanRequest::mutable_lv_id(int index) {
  return lv_id_.Mutable(index);
}
inline void DynamicTripPlanRequest::set_lv_id(int index, const ::std::string& value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanRequest::set_lv_id(int index, const char* value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanRequest::set_lv_id(int index, const char* value, size_t size) {
  lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanRequest::add_lv_id() {
  return lv_id_.Add();
}
inline void DynamicTripPlanRequest::add_lv_id(const ::std::string& value) {
  lv_id_.Add()->assign(value);
}
inline void DynamicTripPlanRequest::add_lv_id(const char* value) {
  lv_id_.Add()->assign(value);
}
inline void DynamicTripPlanRequest::add_lv_id(const char* value, size_t size) {
  lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DynamicTripPlanRequest::lv_id() const {
  return lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DynamicTripPlanRequest::mutable_lv_id() {
  return &lv_id_;
}

// optional string userid = 3;
inline bool DynamicTripPlanRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DynamicTripPlanRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DynamicTripPlanRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DynamicTripPlanRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& DynamicTripPlanRequest::userid() const {
  return *userid_;
}
inline void DynamicTripPlanRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DynamicTripPlanRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DynamicTripPlanRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* DynamicTripPlanRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string cater = 4;
inline int DynamicTripPlanRequest::cater_size() const {
  return cater_.size();
}
inline void DynamicTripPlanRequest::clear_cater() {
  cater_.Clear();
}
inline const ::std::string& DynamicTripPlanRequest::cater(int index) const {
  return cater_.Get(index);
}
inline ::std::string* DynamicTripPlanRequest::mutable_cater(int index) {
  return cater_.Mutable(index);
}
inline void DynamicTripPlanRequest::set_cater(int index, const ::std::string& value) {
  cater_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanRequest::set_cater(int index, const char* value) {
  cater_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanRequest::set_cater(int index, const char* value, size_t size) {
  cater_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanRequest::add_cater() {
  return cater_.Add();
}
inline void DynamicTripPlanRequest::add_cater(const ::std::string& value) {
  cater_.Add()->assign(value);
}
inline void DynamicTripPlanRequest::add_cater(const char* value) {
  cater_.Add()->assign(value);
}
inline void DynamicTripPlanRequest::add_cater(const char* value, size_t size) {
  cater_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DynamicTripPlanRequest::cater() const {
  return cater_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DynamicTripPlanRequest::mutable_cater() {
  return &cater_;
}

// repeated string hotel = 5;
inline int DynamicTripPlanRequest::hotel_size() const {
  return hotel_.size();
}
inline void DynamicTripPlanRequest::clear_hotel() {
  hotel_.Clear();
}
inline const ::std::string& DynamicTripPlanRequest::hotel(int index) const {
  return hotel_.Get(index);
}
inline ::std::string* DynamicTripPlanRequest::mutable_hotel(int index) {
  return hotel_.Mutable(index);
}
inline void DynamicTripPlanRequest::set_hotel(int index, const ::std::string& value) {
  hotel_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanRequest::set_hotel(int index, const char* value) {
  hotel_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanRequest::set_hotel(int index, const char* value, size_t size) {
  hotel_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanRequest::add_hotel() {
  return hotel_.Add();
}
inline void DynamicTripPlanRequest::add_hotel(const ::std::string& value) {
  hotel_.Add()->assign(value);
}
inline void DynamicTripPlanRequest::add_hotel(const char* value) {
  hotel_.Add()->assign(value);
}
inline void DynamicTripPlanRequest::add_hotel(const char* value, size_t size) {
  hotel_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DynamicTripPlanRequest::hotel() const {
  return hotel_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DynamicTripPlanRequest::mutable_hotel() {
  return &hotel_;
}

// repeated .lbs.da.openservice.Arg args = 6;
inline int DynamicTripPlanRequest::args_size() const {
  return args_.size();
}
inline void DynamicTripPlanRequest::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& DynamicTripPlanRequest::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* DynamicTripPlanRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* DynamicTripPlanRequest::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
DynamicTripPlanRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
DynamicTripPlanRequest::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// DynamicTripPlanResponse

// required int32 status = 1;
inline bool DynamicTripPlanResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicTripPlanResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DynamicTripPlanResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DynamicTripPlanResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 DynamicTripPlanResponse::status() const {
  return status_;
}
inline void DynamicTripPlanResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int64 total_distance = 2;
inline bool DynamicTripPlanResponse::has_total_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicTripPlanResponse::set_has_total_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DynamicTripPlanResponse::clear_has_total_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DynamicTripPlanResponse::clear_total_distance() {
  total_distance_ = GOOGLE_LONGLONG(0);
  clear_has_total_distance();
}
inline ::google::protobuf::int64 DynamicTripPlanResponse::total_distance() const {
  return total_distance_;
}
inline void DynamicTripPlanResponse::set_total_distance(::google::protobuf::int64 value) {
  set_has_total_distance();
  total_distance_ = value;
}

// repeated string lv_id = 3;
inline int DynamicTripPlanResponse::lv_id_size() const {
  return lv_id_.size();
}
inline void DynamicTripPlanResponse::clear_lv_id() {
  lv_id_.Clear();
}
inline const ::std::string& DynamicTripPlanResponse::lv_id(int index) const {
  return lv_id_.Get(index);
}
inline ::std::string* DynamicTripPlanResponse::mutable_lv_id(int index) {
  return lv_id_.Mutable(index);
}
inline void DynamicTripPlanResponse::set_lv_id(int index, const ::std::string& value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanResponse::set_lv_id(int index, const char* value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanResponse::set_lv_id(int index, const char* value, size_t size) {
  lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanResponse::add_lv_id() {
  return lv_id_.Add();
}
inline void DynamicTripPlanResponse::add_lv_id(const ::std::string& value) {
  lv_id_.Add()->assign(value);
}
inline void DynamicTripPlanResponse::add_lv_id(const char* value) {
  lv_id_.Add()->assign(value);
}
inline void DynamicTripPlanResponse::add_lv_id(const char* value, size_t size) {
  lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DynamicTripPlanResponse::lv_id() const {
  return lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DynamicTripPlanResponse::mutable_lv_id() {
  return &lv_id_;
}

// repeated .lbs.da.openservice.DayRoute dayroute = 4;
inline int DynamicTripPlanResponse::dayroute_size() const {
  return dayroute_.size();
}
inline void DynamicTripPlanResponse::clear_dayroute() {
  dayroute_.Clear();
}
inline const ::lbs::da::openservice::DayRoute& DynamicTripPlanResponse::dayroute(int index) const {
  return dayroute_.Get(index);
}
inline ::lbs::da::openservice::DayRoute* DynamicTripPlanResponse::mutable_dayroute(int index) {
  return dayroute_.Mutable(index);
}
inline ::lbs::da::openservice::DayRoute* DynamicTripPlanResponse::add_dayroute() {
  return dayroute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRoute >&
DynamicTripPlanResponse::dayroute() const {
  return dayroute_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRoute >*
DynamicTripPlanResponse::mutable_dayroute() {
  return &dayroute_;
}

// repeated string origin_lv_id = 5;
inline int DynamicTripPlanResponse::origin_lv_id_size() const {
  return origin_lv_id_.size();
}
inline void DynamicTripPlanResponse::clear_origin_lv_id() {
  origin_lv_id_.Clear();
}
inline const ::std::string& DynamicTripPlanResponse::origin_lv_id(int index) const {
  return origin_lv_id_.Get(index);
}
inline ::std::string* DynamicTripPlanResponse::mutable_origin_lv_id(int index) {
  return origin_lv_id_.Mutable(index);
}
inline void DynamicTripPlanResponse::set_origin_lv_id(int index, const ::std::string& value) {
  origin_lv_id_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanResponse::set_origin_lv_id(int index, const char* value) {
  origin_lv_id_.Mutable(index)->assign(value);
}
inline void DynamicTripPlanResponse::set_origin_lv_id(int index, const char* value, size_t size) {
  origin_lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanResponse::add_origin_lv_id() {
  return origin_lv_id_.Add();
}
inline void DynamicTripPlanResponse::add_origin_lv_id(const ::std::string& value) {
  origin_lv_id_.Add()->assign(value);
}
inline void DynamicTripPlanResponse::add_origin_lv_id(const char* value) {
  origin_lv_id_.Add()->assign(value);
}
inline void DynamicTripPlanResponse::add_origin_lv_id(const char* value, size_t size) {
  origin_lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DynamicTripPlanResponse::origin_lv_id() const {
  return origin_lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DynamicTripPlanResponse::mutable_origin_lv_id() {
  return &origin_lv_id_;
}

// optional string userid = 6;
inline bool DynamicTripPlanResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DynamicTripPlanResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DynamicTripPlanResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DynamicTripPlanResponse::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& DynamicTripPlanResponse::userid() const {
  return *userid_;
}
inline void DynamicTripPlanResponse::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DynamicTripPlanResponse::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void DynamicTripPlanResponse::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanResponse::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* DynamicTripPlanResponse::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uniq_id = 7;
inline bool DynamicTripPlanResponse::has_uniq_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DynamicTripPlanResponse::set_has_uniq_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DynamicTripPlanResponse::clear_has_uniq_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DynamicTripPlanResponse::clear_uniq_id() {
  if (uniq_id_ != &::google::protobuf::internal::kEmptyString) {
    uniq_id_->clear();
  }
  clear_has_uniq_id();
}
inline const ::std::string& DynamicTripPlanResponse::uniq_id() const {
  return *uniq_id_;
}
inline void DynamicTripPlanResponse::set_uniq_id(const ::std::string& value) {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  uniq_id_->assign(value);
}
inline void DynamicTripPlanResponse::set_uniq_id(const char* value) {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  uniq_id_->assign(value);
}
inline void DynamicTripPlanResponse::set_uniq_id(const char* value, size_t size) {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  uniq_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DynamicTripPlanResponse::mutable_uniq_id() {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  return uniq_id_;
}
inline ::std::string* DynamicTripPlanResponse::release_uniq_id() {
  clear_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniq_id_;
    uniq_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg args = 8;
inline int DynamicTripPlanResponse::args_size() const {
  return args_.size();
}
inline void DynamicTripPlanResponse::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& DynamicTripPlanResponse::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* DynamicTripPlanResponse::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* DynamicTripPlanResponse::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
DynamicTripPlanResponse::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
DynamicTripPlanResponse::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// DayRouteInfo

// repeated string lv_id = 1;
inline int DayRouteInfo::lv_id_size() const {
  return lv_id_.size();
}
inline void DayRouteInfo::clear_lv_id() {
  lv_id_.Clear();
}
inline const ::std::string& DayRouteInfo::lv_id(int index) const {
  return lv_id_.Get(index);
}
inline ::std::string* DayRouteInfo::mutable_lv_id(int index) {
  return lv_id_.Mutable(index);
}
inline void DayRouteInfo::set_lv_id(int index, const ::std::string& value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_lv_id(int index, const char* value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_lv_id(int index, const char* value, size_t size) {
  lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRouteInfo::add_lv_id() {
  return lv_id_.Add();
}
inline void DayRouteInfo::add_lv_id(const ::std::string& value) {
  lv_id_.Add()->assign(value);
}
inline void DayRouteInfo::add_lv_id(const char* value) {
  lv_id_.Add()->assign(value);
}
inline void DayRouteInfo::add_lv_id(const char* value, size_t size) {
  lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRouteInfo::lv_id() const {
  return lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRouteInfo::mutable_lv_id() {
  return &lv_id_;
}

// optional double scene_dura_time = 2;
inline bool DayRouteInfo::has_scene_dura_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DayRouteInfo::set_has_scene_dura_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DayRouteInfo::clear_has_scene_dura_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DayRouteInfo::clear_scene_dura_time() {
  scene_dura_time_ = 0;
  clear_has_scene_dura_time();
}
inline double DayRouteInfo::scene_dura_time() const {
  return scene_dura_time_;
}
inline void DayRouteInfo::set_scene_dura_time(double value) {
  set_has_scene_dura_time();
  scene_dura_time_ = value;
}

// repeated string cater = 3;
inline int DayRouteInfo::cater_size() const {
  return cater_.size();
}
inline void DayRouteInfo::clear_cater() {
  cater_.Clear();
}
inline const ::std::string& DayRouteInfo::cater(int index) const {
  return cater_.Get(index);
}
inline ::std::string* DayRouteInfo::mutable_cater(int index) {
  return cater_.Mutable(index);
}
inline void DayRouteInfo::set_cater(int index, const ::std::string& value) {
  cater_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_cater(int index, const char* value) {
  cater_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_cater(int index, const char* value, size_t size) {
  cater_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRouteInfo::add_cater() {
  return cater_.Add();
}
inline void DayRouteInfo::add_cater(const ::std::string& value) {
  cater_.Add()->assign(value);
}
inline void DayRouteInfo::add_cater(const char* value) {
  cater_.Add()->assign(value);
}
inline void DayRouteInfo::add_cater(const char* value, size_t size) {
  cater_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRouteInfo::cater() const {
  return cater_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRouteInfo::mutable_cater() {
  return &cater_;
}

// repeated string hotel = 4;
inline int DayRouteInfo::hotel_size() const {
  return hotel_.size();
}
inline void DayRouteInfo::clear_hotel() {
  hotel_.Clear();
}
inline const ::std::string& DayRouteInfo::hotel(int index) const {
  return hotel_.Get(index);
}
inline ::std::string* DayRouteInfo::mutable_hotel(int index) {
  return hotel_.Mutable(index);
}
inline void DayRouteInfo::set_hotel(int index, const ::std::string& value) {
  hotel_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_hotel(int index, const char* value) {
  hotel_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_hotel(int index, const char* value, size_t size) {
  hotel_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRouteInfo::add_hotel() {
  return hotel_.Add();
}
inline void DayRouteInfo::add_hotel(const ::std::string& value) {
  hotel_.Add()->assign(value);
}
inline void DayRouteInfo::add_hotel(const char* value) {
  hotel_.Add()->assign(value);
}
inline void DayRouteInfo::add_hotel(const char* value, size_t size) {
  hotel_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRouteInfo::hotel() const {
  return hotel_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRouteInfo::mutable_hotel() {
  return &hotel_;
}

// repeated string lvid_cater_hotel = 5;
inline int DayRouteInfo::lvid_cater_hotel_size() const {
  return lvid_cater_hotel_.size();
}
inline void DayRouteInfo::clear_lvid_cater_hotel() {
  lvid_cater_hotel_.Clear();
}
inline const ::std::string& DayRouteInfo::lvid_cater_hotel(int index) const {
  return lvid_cater_hotel_.Get(index);
}
inline ::std::string* DayRouteInfo::mutable_lvid_cater_hotel(int index) {
  return lvid_cater_hotel_.Mutable(index);
}
inline void DayRouteInfo::set_lvid_cater_hotel(int index, const ::std::string& value) {
  lvid_cater_hotel_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_lvid_cater_hotel(int index, const char* value) {
  lvid_cater_hotel_.Mutable(index)->assign(value);
}
inline void DayRouteInfo::set_lvid_cater_hotel(int index, const char* value, size_t size) {
  lvid_cater_hotel_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRouteInfo::add_lvid_cater_hotel() {
  return lvid_cater_hotel_.Add();
}
inline void DayRouteInfo::add_lvid_cater_hotel(const ::std::string& value) {
  lvid_cater_hotel_.Add()->assign(value);
}
inline void DayRouteInfo::add_lvid_cater_hotel(const char* value) {
  lvid_cater_hotel_.Add()->assign(value);
}
inline void DayRouteInfo::add_lvid_cater_hotel(const char* value, size_t size) {
  lvid_cater_hotel_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DayRouteInfo::lvid_cater_hotel() const {
  return lvid_cater_hotel_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DayRouteInfo::mutable_lvid_cater_hotel() {
  return &lvid_cater_hotel_;
}

// optional string opt_json_str = 6;
inline bool DayRouteInfo::has_opt_json_str() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DayRouteInfo::set_has_opt_json_str() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DayRouteInfo::clear_has_opt_json_str() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DayRouteInfo::clear_opt_json_str() {
  if (opt_json_str_ != &::google::protobuf::internal::kEmptyString) {
    opt_json_str_->clear();
  }
  clear_has_opt_json_str();
}
inline const ::std::string& DayRouteInfo::opt_json_str() const {
  return *opt_json_str_;
}
inline void DayRouteInfo::set_opt_json_str(const ::std::string& value) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(value);
}
inline void DayRouteInfo::set_opt_json_str(const char* value) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(value);
}
inline void DayRouteInfo::set_opt_json_str(const char* value, size_t size) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DayRouteInfo::mutable_opt_json_str() {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  return opt_json_str_;
}
inline ::std::string* DayRouteInfo::release_opt_json_str() {
  clear_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_json_str_;
    opt_json_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg args = 7;
inline int DayRouteInfo::args_size() const {
  return args_.size();
}
inline void DayRouteInfo::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& DayRouteInfo::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* DayRouteInfo::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* DayRouteInfo::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
DayRouteInfo::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
DayRouteInfo::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// LvTripPlanRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool LvTripPlanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LvTripPlanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LvTripPlanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LvTripPlanRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& LvTripPlanRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* LvTripPlanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* LvTripPlanRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated string lv_id = 2;
inline int LvTripPlanRequest::lv_id_size() const {
  return lv_id_.size();
}
inline void LvTripPlanRequest::clear_lv_id() {
  lv_id_.Clear();
}
inline const ::std::string& LvTripPlanRequest::lv_id(int index) const {
  return lv_id_.Get(index);
}
inline ::std::string* LvTripPlanRequest::mutable_lv_id(int index) {
  return lv_id_.Mutable(index);
}
inline void LvTripPlanRequest::set_lv_id(int index, const ::std::string& value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void LvTripPlanRequest::set_lv_id(int index, const char* value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void LvTripPlanRequest::set_lv_id(int index, const char* value, size_t size) {
  lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanRequest::add_lv_id() {
  return lv_id_.Add();
}
inline void LvTripPlanRequest::add_lv_id(const ::std::string& value) {
  lv_id_.Add()->assign(value);
}
inline void LvTripPlanRequest::add_lv_id(const char* value) {
  lv_id_.Add()->assign(value);
}
inline void LvTripPlanRequest::add_lv_id(const char* value, size_t size) {
  lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LvTripPlanRequest::lv_id() const {
  return lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LvTripPlanRequest::mutable_lv_id() {
  return &lv_id_;
}

// optional string userid = 3;
inline bool LvTripPlanRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LvTripPlanRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LvTripPlanRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LvTripPlanRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& LvTripPlanRequest::userid() const {
  return *userid_;
}
inline void LvTripPlanRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LvTripPlanRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LvTripPlanRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* LvTripPlanRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string algorithmId = 4;
inline bool LvTripPlanRequest::has_algorithmid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LvTripPlanRequest::set_has_algorithmid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LvTripPlanRequest::clear_has_algorithmid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LvTripPlanRequest::clear_algorithmid() {
  if (algorithmid_ != &::google::protobuf::internal::kEmptyString) {
    algorithmid_->clear();
  }
  clear_has_algorithmid();
}
inline const ::std::string& LvTripPlanRequest::algorithmid() const {
  return *algorithmid_;
}
inline void LvTripPlanRequest::set_algorithmid(const ::std::string& value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void LvTripPlanRequest::set_algorithmid(const char* value) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(value);
}
inline void LvTripPlanRequest::set_algorithmid(const char* value, size_t size) {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  algorithmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanRequest::mutable_algorithmid() {
  set_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    algorithmid_ = new ::std::string;
  }
  return algorithmid_;
}
inline ::std::string* LvTripPlanRequest::release_algorithmid() {
  clear_has_algorithmid();
  if (algorithmid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = algorithmid_;
    algorithmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string cater = 5;
inline int LvTripPlanRequest::cater_size() const {
  return cater_.size();
}
inline void LvTripPlanRequest::clear_cater() {
  cater_.Clear();
}
inline const ::std::string& LvTripPlanRequest::cater(int index) const {
  return cater_.Get(index);
}
inline ::std::string* LvTripPlanRequest::mutable_cater(int index) {
  return cater_.Mutable(index);
}
inline void LvTripPlanRequest::set_cater(int index, const ::std::string& value) {
  cater_.Mutable(index)->assign(value);
}
inline void LvTripPlanRequest::set_cater(int index, const char* value) {
  cater_.Mutable(index)->assign(value);
}
inline void LvTripPlanRequest::set_cater(int index, const char* value, size_t size) {
  cater_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanRequest::add_cater() {
  return cater_.Add();
}
inline void LvTripPlanRequest::add_cater(const ::std::string& value) {
  cater_.Add()->assign(value);
}
inline void LvTripPlanRequest::add_cater(const char* value) {
  cater_.Add()->assign(value);
}
inline void LvTripPlanRequest::add_cater(const char* value, size_t size) {
  cater_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LvTripPlanRequest::cater() const {
  return cater_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LvTripPlanRequest::mutable_cater() {
  return &cater_;
}

// repeated string hotel = 6;
inline int LvTripPlanRequest::hotel_size() const {
  return hotel_.size();
}
inline void LvTripPlanRequest::clear_hotel() {
  hotel_.Clear();
}
inline const ::std::string& LvTripPlanRequest::hotel(int index) const {
  return hotel_.Get(index);
}
inline ::std::string* LvTripPlanRequest::mutable_hotel(int index) {
  return hotel_.Mutable(index);
}
inline void LvTripPlanRequest::set_hotel(int index, const ::std::string& value) {
  hotel_.Mutable(index)->assign(value);
}
inline void LvTripPlanRequest::set_hotel(int index, const char* value) {
  hotel_.Mutable(index)->assign(value);
}
inline void LvTripPlanRequest::set_hotel(int index, const char* value, size_t size) {
  hotel_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanRequest::add_hotel() {
  return hotel_.Add();
}
inline void LvTripPlanRequest::add_hotel(const ::std::string& value) {
  hotel_.Add()->assign(value);
}
inline void LvTripPlanRequest::add_hotel(const char* value) {
  hotel_.Add()->assign(value);
}
inline void LvTripPlanRequest::add_hotel(const char* value, size_t size) {
  hotel_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LvTripPlanRequest::hotel() const {
  return hotel_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LvTripPlanRequest::mutable_hotel() {
  return &hotel_;
}

// optional string opt_json_str = 7;
inline bool LvTripPlanRequest::has_opt_json_str() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LvTripPlanRequest::set_has_opt_json_str() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LvTripPlanRequest::clear_has_opt_json_str() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LvTripPlanRequest::clear_opt_json_str() {
  if (opt_json_str_ != &::google::protobuf::internal::kEmptyString) {
    opt_json_str_->clear();
  }
  clear_has_opt_json_str();
}
inline const ::std::string& LvTripPlanRequest::opt_json_str() const {
  return *opt_json_str_;
}
inline void LvTripPlanRequest::set_opt_json_str(const ::std::string& value) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(value);
}
inline void LvTripPlanRequest::set_opt_json_str(const char* value) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(value);
}
inline void LvTripPlanRequest::set_opt_json_str(const char* value, size_t size) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanRequest::mutable_opt_json_str() {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  return opt_json_str_;
}
inline ::std::string* LvTripPlanRequest::release_opt_json_str() {
  clear_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_json_str_;
    opt_json_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg args = 8;
inline int LvTripPlanRequest::args_size() const {
  return args_.size();
}
inline void LvTripPlanRequest::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& LvTripPlanRequest::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* LvTripPlanRequest::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* LvTripPlanRequest::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
LvTripPlanRequest::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
LvTripPlanRequest::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// LvTripPlanResponse

// required int32 status = 1;
inline bool LvTripPlanResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LvTripPlanResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LvTripPlanResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LvTripPlanResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LvTripPlanResponse::status() const {
  return status_;
}
inline void LvTripPlanResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int64 original_total_distance = 2;
inline bool LvTripPlanResponse::has_original_total_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LvTripPlanResponse::set_has_original_total_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LvTripPlanResponse::clear_has_original_total_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LvTripPlanResponse::clear_original_total_distance() {
  original_total_distance_ = GOOGLE_LONGLONG(0);
  clear_has_original_total_distance();
}
inline ::google::protobuf::int64 LvTripPlanResponse::original_total_distance() const {
  return original_total_distance_;
}
inline void LvTripPlanResponse::set_original_total_distance(::google::protobuf::int64 value) {
  set_has_original_total_distance();
  original_total_distance_ = value;
}

// required int64 original_total_time = 3;
inline bool LvTripPlanResponse::has_original_total_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LvTripPlanResponse::set_has_original_total_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LvTripPlanResponse::clear_has_original_total_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LvTripPlanResponse::clear_original_total_time() {
  original_total_time_ = GOOGLE_LONGLONG(0);
  clear_has_original_total_time();
}
inline ::google::protobuf::int64 LvTripPlanResponse::original_total_time() const {
  return original_total_time_;
}
inline void LvTripPlanResponse::set_original_total_time(::google::protobuf::int64 value) {
  set_has_original_total_time();
  original_total_time_ = value;
}

// required int64 planned_total_distance = 4;
inline bool LvTripPlanResponse::has_planned_total_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LvTripPlanResponse::set_has_planned_total_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LvTripPlanResponse::clear_has_planned_total_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LvTripPlanResponse::clear_planned_total_distance() {
  planned_total_distance_ = GOOGLE_LONGLONG(0);
  clear_has_planned_total_distance();
}
inline ::google::protobuf::int64 LvTripPlanResponse::planned_total_distance() const {
  return planned_total_distance_;
}
inline void LvTripPlanResponse::set_planned_total_distance(::google::protobuf::int64 value) {
  set_has_planned_total_distance();
  planned_total_distance_ = value;
}

// required int64 planned_total_time = 5;
inline bool LvTripPlanResponse::has_planned_total_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LvTripPlanResponse::set_has_planned_total_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LvTripPlanResponse::clear_has_planned_total_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LvTripPlanResponse::clear_planned_total_time() {
  planned_total_time_ = GOOGLE_LONGLONG(0);
  clear_has_planned_total_time();
}
inline ::google::protobuf::int64 LvTripPlanResponse::planned_total_time() const {
  return planned_total_time_;
}
inline void LvTripPlanResponse::set_planned_total_time(::google::protobuf::int64 value) {
  set_has_planned_total_time();
  planned_total_time_ = value;
}

// repeated string lv_id = 8;
inline int LvTripPlanResponse::lv_id_size() const {
  return lv_id_.size();
}
inline void LvTripPlanResponse::clear_lv_id() {
  lv_id_.Clear();
}
inline const ::std::string& LvTripPlanResponse::lv_id(int index) const {
  return lv_id_.Get(index);
}
inline ::std::string* LvTripPlanResponse::mutable_lv_id(int index) {
  return lv_id_.Mutable(index);
}
inline void LvTripPlanResponse::set_lv_id(int index, const ::std::string& value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void LvTripPlanResponse::set_lv_id(int index, const char* value) {
  lv_id_.Mutable(index)->assign(value);
}
inline void LvTripPlanResponse::set_lv_id(int index, const char* value, size_t size) {
  lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanResponse::add_lv_id() {
  return lv_id_.Add();
}
inline void LvTripPlanResponse::add_lv_id(const ::std::string& value) {
  lv_id_.Add()->assign(value);
}
inline void LvTripPlanResponse::add_lv_id(const char* value) {
  lv_id_.Add()->assign(value);
}
inline void LvTripPlanResponse::add_lv_id(const char* value, size_t size) {
  lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LvTripPlanResponse::lv_id() const {
  return lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LvTripPlanResponse::mutable_lv_id() {
  return &lv_id_;
}

// repeated .lbs.da.openservice.DayRouteInfo dayroute = 9;
inline int LvTripPlanResponse::dayroute_size() const {
  return dayroute_.size();
}
inline void LvTripPlanResponse::clear_dayroute() {
  dayroute_.Clear();
}
inline const ::lbs::da::openservice::DayRouteInfo& LvTripPlanResponse::dayroute(int index) const {
  return dayroute_.Get(index);
}
inline ::lbs::da::openservice::DayRouteInfo* LvTripPlanResponse::mutable_dayroute(int index) {
  return dayroute_.Mutable(index);
}
inline ::lbs::da::openservice::DayRouteInfo* LvTripPlanResponse::add_dayroute() {
  return dayroute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRouteInfo >&
LvTripPlanResponse::dayroute() const {
  return dayroute_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::DayRouteInfo >*
LvTripPlanResponse::mutable_dayroute() {
  return &dayroute_;
}

// repeated string origin_lv_id = 10;
inline int LvTripPlanResponse::origin_lv_id_size() const {
  return origin_lv_id_.size();
}
inline void LvTripPlanResponse::clear_origin_lv_id() {
  origin_lv_id_.Clear();
}
inline const ::std::string& LvTripPlanResponse::origin_lv_id(int index) const {
  return origin_lv_id_.Get(index);
}
inline ::std::string* LvTripPlanResponse::mutable_origin_lv_id(int index) {
  return origin_lv_id_.Mutable(index);
}
inline void LvTripPlanResponse::set_origin_lv_id(int index, const ::std::string& value) {
  origin_lv_id_.Mutable(index)->assign(value);
}
inline void LvTripPlanResponse::set_origin_lv_id(int index, const char* value) {
  origin_lv_id_.Mutable(index)->assign(value);
}
inline void LvTripPlanResponse::set_origin_lv_id(int index, const char* value, size_t size) {
  origin_lv_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanResponse::add_origin_lv_id() {
  return origin_lv_id_.Add();
}
inline void LvTripPlanResponse::add_origin_lv_id(const ::std::string& value) {
  origin_lv_id_.Add()->assign(value);
}
inline void LvTripPlanResponse::add_origin_lv_id(const char* value) {
  origin_lv_id_.Add()->assign(value);
}
inline void LvTripPlanResponse::add_origin_lv_id(const char* value, size_t size) {
  origin_lv_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LvTripPlanResponse::origin_lv_id() const {
  return origin_lv_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LvTripPlanResponse::mutable_origin_lv_id() {
  return &origin_lv_id_;
}

// optional string userid = 11;
inline bool LvTripPlanResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LvTripPlanResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LvTripPlanResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LvTripPlanResponse::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& LvTripPlanResponse::userid() const {
  return *userid_;
}
inline void LvTripPlanResponse::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LvTripPlanResponse::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LvTripPlanResponse::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanResponse::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* LvTripPlanResponse::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uniq_id = 12;
inline bool LvTripPlanResponse::has_uniq_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LvTripPlanResponse::set_has_uniq_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LvTripPlanResponse::clear_has_uniq_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LvTripPlanResponse::clear_uniq_id() {
  if (uniq_id_ != &::google::protobuf::internal::kEmptyString) {
    uniq_id_->clear();
  }
  clear_has_uniq_id();
}
inline const ::std::string& LvTripPlanResponse::uniq_id() const {
  return *uniq_id_;
}
inline void LvTripPlanResponse::set_uniq_id(const ::std::string& value) {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  uniq_id_->assign(value);
}
inline void LvTripPlanResponse::set_uniq_id(const char* value) {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  uniq_id_->assign(value);
}
inline void LvTripPlanResponse::set_uniq_id(const char* value, size_t size) {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  uniq_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanResponse::mutable_uniq_id() {
  set_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    uniq_id_ = new ::std::string;
  }
  return uniq_id_;
}
inline ::std::string* LvTripPlanResponse::release_uniq_id() {
  clear_has_uniq_id();
  if (uniq_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniq_id_;
    uniq_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string opt_json_str = 13;
inline bool LvTripPlanResponse::has_opt_json_str() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LvTripPlanResponse::set_has_opt_json_str() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LvTripPlanResponse::clear_has_opt_json_str() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LvTripPlanResponse::clear_opt_json_str() {
  if (opt_json_str_ != &::google::protobuf::internal::kEmptyString) {
    opt_json_str_->clear();
  }
  clear_has_opt_json_str();
}
inline const ::std::string& LvTripPlanResponse::opt_json_str() const {
  return *opt_json_str_;
}
inline void LvTripPlanResponse::set_opt_json_str(const ::std::string& value) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(value);
}
inline void LvTripPlanResponse::set_opt_json_str(const char* value) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(value);
}
inline void LvTripPlanResponse::set_opt_json_str(const char* value, size_t size) {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  opt_json_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LvTripPlanResponse::mutable_opt_json_str() {
  set_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    opt_json_str_ = new ::std::string;
  }
  return opt_json_str_;
}
inline ::std::string* LvTripPlanResponse::release_opt_json_str() {
  clear_has_opt_json_str();
  if (opt_json_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_json_str_;
    opt_json_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.Arg args = 14;
inline int LvTripPlanResponse::args_size() const {
  return args_.size();
}
inline void LvTripPlanResponse::clear_args() {
  args_.Clear();
}
inline const ::lbs::da::openservice::Arg& LvTripPlanResponse::args(int index) const {
  return args_.Get(index);
}
inline ::lbs::da::openservice::Arg* LvTripPlanResponse::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::lbs::da::openservice::Arg* LvTripPlanResponse::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >&
LvTripPlanResponse::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Arg >*
LvTripPlanResponse::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// WifiFinger

// required string mac_addr = 1;
inline bool WifiFinger::has_mac_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiFinger::set_has_mac_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WifiFinger::clear_has_mac_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WifiFinger::clear_mac_addr() {
  if (mac_addr_ != &::google::protobuf::internal::kEmptyString) {
    mac_addr_->clear();
  }
  clear_has_mac_addr();
}
inline const ::std::string& WifiFinger::mac_addr() const {
  return *mac_addr_;
}
inline void WifiFinger::set_mac_addr(const ::std::string& value) {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  mac_addr_->assign(value);
}
inline void WifiFinger::set_mac_addr(const char* value) {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  mac_addr_->assign(value);
}
inline void WifiFinger::set_mac_addr(const char* value, size_t size) {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  mac_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiFinger::mutable_mac_addr() {
  set_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    mac_addr_ = new ::std::string;
  }
  return mac_addr_;
}
inline ::std::string* WifiFinger::release_mac_addr() {
  clear_has_mac_addr();
  if (mac_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_addr_;
    mac_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 strength = 2;
inline bool WifiFinger::has_strength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiFinger::set_has_strength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WifiFinger::clear_has_strength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WifiFinger::clear_strength() {
  strength_ = 0;
  clear_has_strength();
}
inline ::google::protobuf::int32 WifiFinger::strength() const {
  return strength_;
}
inline void WifiFinger::set_strength(::google::protobuf::int32 value) {
  set_has_strength();
  strength_ = value;
}

// -------------------------------------------------------------------

// PlaceSemanticRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool PlaceSemanticRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaceSemanticRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaceSemanticRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaceSemanticRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& PlaceSemanticRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* PlaceSemanticRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* PlaceSemanticRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .lbs.da.openservice.WifiFinger wifi = 2;
inline int PlaceSemanticRequest::wifi_size() const {
  return wifi_.size();
}
inline void PlaceSemanticRequest::clear_wifi() {
  wifi_.Clear();
}
inline const ::lbs::da::openservice::WifiFinger& PlaceSemanticRequest::wifi(int index) const {
  return wifi_.Get(index);
}
inline ::lbs::da::openservice::WifiFinger* PlaceSemanticRequest::mutable_wifi(int index) {
  return wifi_.Mutable(index);
}
inline ::lbs::da::openservice::WifiFinger* PlaceSemanticRequest::add_wifi() {
  return wifi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::WifiFinger >&
PlaceSemanticRequest::wifi() const {
  return wifi_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::WifiFinger >*
PlaceSemanticRequest::mutable_wifi() {
  return &wifi_;
}

// optional double longitude = 3;
inline bool PlaceSemanticRequest::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlaceSemanticRequest::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlaceSemanticRequest::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlaceSemanticRequest::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double PlaceSemanticRequest::longitude() const {
  return longitude_;
}
inline void PlaceSemanticRequest::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 4;
inline bool PlaceSemanticRequest::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlaceSemanticRequest::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlaceSemanticRequest::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlaceSemanticRequest::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double PlaceSemanticRequest::latitude() const {
  return latitude_;
}
inline void PlaceSemanticRequest::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional string cuid = 5;
inline bool PlaceSemanticRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlaceSemanticRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlaceSemanticRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlaceSemanticRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& PlaceSemanticRequest::cuid() const {
  return *cuid_;
}
inline void PlaceSemanticRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void PlaceSemanticRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void PlaceSemanticRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaceSemanticRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* PlaceSemanticRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 distance = 6;
inline bool PlaceSemanticRequest::has_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlaceSemanticRequest::set_has_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlaceSemanticRequest::clear_has_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlaceSemanticRequest::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 PlaceSemanticRequest::distance() const {
  return distance_;
}
inline void PlaceSemanticRequest::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// optional double similarity_threadhold = 7;
inline bool PlaceSemanticRequest::has_similarity_threadhold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlaceSemanticRequest::set_has_similarity_threadhold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlaceSemanticRequest::clear_has_similarity_threadhold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlaceSemanticRequest::clear_similarity_threadhold() {
  similarity_threadhold_ = 0;
  clear_has_similarity_threadhold();
}
inline double PlaceSemanticRequest::similarity_threadhold() const {
  return similarity_threadhold_;
}
inline void PlaceSemanticRequest::set_similarity_threadhold(double value) {
  set_has_similarity_threadhold();
  similarity_threadhold_ = value;
}

// optional string algorithm_id = 8;
inline bool PlaceSemanticRequest::has_algorithm_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlaceSemanticRequest::set_has_algorithm_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlaceSemanticRequest::clear_has_algorithm_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlaceSemanticRequest::clear_algorithm_id() {
  if (algorithm_id_ != &::google::protobuf::internal::kEmptyString) {
    algorithm_id_->clear();
  }
  clear_has_algorithm_id();
}
inline const ::std::string& PlaceSemanticRequest::algorithm_id() const {
  return *algorithm_id_;
}
inline void PlaceSemanticRequest::set_algorithm_id(const ::std::string& value) {
  set_has_algorithm_id();
  if (algorithm_id_ == &::google::protobuf::internal::kEmptyString) {
    algorithm_id_ = new ::std::string;
  }
  algorithm_id_->assign(value);
}
inline void PlaceSemanticRequest::set_algorithm_id(const char* value) {
  set_has_algorithm_id();
  if (algorithm_id_ == &::google::protobuf::internal::kEmptyString) {
    algorithm_id_ = new ::std::string;
  }
  algorithm_id_->assign(value);
}
inline void PlaceSemanticRequest::set_algorithm_id(const char* value, size_t size) {
  set_has_algorithm_id();
  if (algorithm_id_ == &::google::protobuf::internal::kEmptyString) {
    algorithm_id_ = new ::std::string;
  }
  algorithm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaceSemanticRequest::mutable_algorithm_id() {
  set_has_algorithm_id();
  if (algorithm_id_ == &::google::protobuf::internal::kEmptyString) {
    algorithm_id_ = new ::std::string;
  }
  return algorithm_id_;
}
inline ::std::string* PlaceSemanticRequest::release_algorithm_id() {
  clear_has_algorithm_id();
  if (algorithm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = algorithm_id_;
    algorithm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PoiProbability

// required string poi = 1;
inline bool PoiProbability::has_poi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoiProbability::set_has_poi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoiProbability::clear_has_poi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoiProbability::clear_poi() {
  if (poi_ != &::google::protobuf::internal::kEmptyString) {
    poi_->clear();
  }
  clear_has_poi();
}
inline const ::std::string& PoiProbability::poi() const {
  return *poi_;
}
inline void PoiProbability::set_poi(const ::std::string& value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void PoiProbability::set_poi(const char* value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void PoiProbability::set_poi(const char* value, size_t size) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiProbability::mutable_poi() {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  return poi_;
}
inline ::std::string* PoiProbability::release_poi() {
  clear_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_;
    poi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double probability = 2;
inline bool PoiProbability::has_probability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoiProbability::set_has_probability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoiProbability::clear_has_probability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoiProbability::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline double PoiProbability::probability() const {
  return probability_;
}
inline void PoiProbability::set_probability(double value) {
  set_has_probability();
  probability_ = value;
}

// -------------------------------------------------------------------

// PlaceSemanticResponse

// repeated string aoi_id = 1;
inline int PlaceSemanticResponse::aoi_id_size() const {
  return aoi_id_.size();
}
inline void PlaceSemanticResponse::clear_aoi_id() {
  aoi_id_.Clear();
}
inline const ::std::string& PlaceSemanticResponse::aoi_id(int index) const {
  return aoi_id_.Get(index);
}
inline ::std::string* PlaceSemanticResponse::mutable_aoi_id(int index) {
  return aoi_id_.Mutable(index);
}
inline void PlaceSemanticResponse::set_aoi_id(int index, const ::std::string& value) {
  aoi_id_.Mutable(index)->assign(value);
}
inline void PlaceSemanticResponse::set_aoi_id(int index, const char* value) {
  aoi_id_.Mutable(index)->assign(value);
}
inline void PlaceSemanticResponse::set_aoi_id(int index, const char* value, size_t size) {
  aoi_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaceSemanticResponse::add_aoi_id() {
  return aoi_id_.Add();
}
inline void PlaceSemanticResponse::add_aoi_id(const ::std::string& value) {
  aoi_id_.Add()->assign(value);
}
inline void PlaceSemanticResponse::add_aoi_id(const char* value) {
  aoi_id_.Add()->assign(value);
}
inline void PlaceSemanticResponse::add_aoi_id(const char* value, size_t size) {
  aoi_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlaceSemanticResponse::aoi_id() const {
  return aoi_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlaceSemanticResponse::mutable_aoi_id() {
  return &aoi_id_;
}

// repeated .lbs.da.openservice.PoiProbability poi_prob_list = 2;
inline int PlaceSemanticResponse::poi_prob_list_size() const {
  return poi_prob_list_.size();
}
inline void PlaceSemanticResponse::clear_poi_prob_list() {
  poi_prob_list_.Clear();
}
inline const ::lbs::da::openservice::PoiProbability& PlaceSemanticResponse::poi_prob_list(int index) const {
  return poi_prob_list_.Get(index);
}
inline ::lbs::da::openservice::PoiProbability* PlaceSemanticResponse::mutable_poi_prob_list(int index) {
  return poi_prob_list_.Mutable(index);
}
inline ::lbs::da::openservice::PoiProbability* PlaceSemanticResponse::add_poi_prob_list() {
  return poi_prob_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiProbability >&
PlaceSemanticResponse::poi_prob_list() const {
  return poi_prob_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiProbability >*
PlaceSemanticResponse::mutable_poi_prob_list() {
  return &poi_prob_list_;
}

// -------------------------------------------------------------------

// NuomiUserPreferenceRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool NuomiUserPreferenceRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NuomiUserPreferenceRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NuomiUserPreferenceRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NuomiUserPreferenceRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& NuomiUserPreferenceRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* NuomiUserPreferenceRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* NuomiUserPreferenceRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required .lbs.da.openservice.RequestIdType id_type = 2;
inline bool NuomiUserPreferenceRequest::has_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NuomiUserPreferenceRequest::set_has_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NuomiUserPreferenceRequest::clear_has_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NuomiUserPreferenceRequest::clear_id_type() {
  id_type_ = 1;
  clear_has_id_type();
}
inline lbs::da::openservice::RequestIdType NuomiUserPreferenceRequest::id_type() const {
  return static_cast< lbs::da::openservice::RequestIdType >(id_type_);
}
inline void NuomiUserPreferenceRequest::set_id_type(lbs::da::openservice::RequestIdType value) {
  GOOGLE_DCHECK(lbs::da::openservice::RequestIdType_IsValid(value));
  set_has_id_type();
  id_type_ = value;
}

// required string id = 3;
inline bool NuomiUserPreferenceRequest::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NuomiUserPreferenceRequest::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NuomiUserPreferenceRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NuomiUserPreferenceRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NuomiUserPreferenceRequest::id() const {
  return *id_;
}
inline void NuomiUserPreferenceRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NuomiUserPreferenceRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NuomiUserPreferenceRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NuomiUserPreferenceRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* NuomiUserPreferenceRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lbs.da.openservice.NuomiDataType data_type = 4;
inline bool NuomiUserPreferenceRequest::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NuomiUserPreferenceRequest::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NuomiUserPreferenceRequest::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NuomiUserPreferenceRequest::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline lbs::da::openservice::NuomiDataType NuomiUserPreferenceRequest::data_type() const {
  return static_cast< lbs::da::openservice::NuomiDataType >(data_type_);
}
inline void NuomiUserPreferenceRequest::set_data_type(lbs::da::openservice::NuomiDataType value) {
  GOOGLE_DCHECK(lbs::da::openservice::NuomiDataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
}

// repeated string feature_names = 5;
inline int NuomiUserPreferenceRequest::feature_names_size() const {
  return feature_names_.size();
}
inline void NuomiUserPreferenceRequest::clear_feature_names() {
  feature_names_.Clear();
}
inline const ::std::string& NuomiUserPreferenceRequest::feature_names(int index) const {
  return feature_names_.Get(index);
}
inline ::std::string* NuomiUserPreferenceRequest::mutable_feature_names(int index) {
  return feature_names_.Mutable(index);
}
inline void NuomiUserPreferenceRequest::set_feature_names(int index, const ::std::string& value) {
  feature_names_.Mutable(index)->assign(value);
}
inline void NuomiUserPreferenceRequest::set_feature_names(int index, const char* value) {
  feature_names_.Mutable(index)->assign(value);
}
inline void NuomiUserPreferenceRequest::set_feature_names(int index, const char* value, size_t size) {
  feature_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NuomiUserPreferenceRequest::add_feature_names() {
  return feature_names_.Add();
}
inline void NuomiUserPreferenceRequest::add_feature_names(const ::std::string& value) {
  feature_names_.Add()->assign(value);
}
inline void NuomiUserPreferenceRequest::add_feature_names(const char* value) {
  feature_names_.Add()->assign(value);
}
inline void NuomiUserPreferenceRequest::add_feature_names(const char* value, size_t size) {
  feature_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NuomiUserPreferenceRequest::feature_names() const {
  return feature_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NuomiUserPreferenceRequest::mutable_feature_names() {
  return &feature_names_;
}

// -------------------------------------------------------------------

// ScoreInfo

// required string featureid = 1;
inline bool ScoreInfo::has_featureid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoreInfo::set_has_featureid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoreInfo::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoreInfo::clear_featureid() {
  if (featureid_ != &::google::protobuf::internal::kEmptyString) {
    featureid_->clear();
  }
  clear_has_featureid();
}
inline const ::std::string& ScoreInfo::featureid() const {
  return *featureid_;
}
inline void ScoreInfo::set_featureid(const ::std::string& value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void ScoreInfo::set_featureid(const char* value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void ScoreInfo::set_featureid(const char* value, size_t size) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScoreInfo::mutable_featureid() {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  return featureid_;
}
inline ::std::string* ScoreInfo::release_featureid() {
  clear_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureid_;
    featureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double score = 2;
inline bool ScoreInfo::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoreInfo::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoreInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoreInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double ScoreInfo::score() const {
  return score_;
}
inline void ScoreInfo::set_score(double value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// FeatureInfo

// required string feature_name = 1;
inline bool FeatureInfo::has_feature_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureInfo::set_has_feature_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureInfo::clear_has_feature_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureInfo::clear_feature_name() {
  if (feature_name_ != &::google::protobuf::internal::kEmptyString) {
    feature_name_->clear();
  }
  clear_has_feature_name();
}
inline const ::std::string& FeatureInfo::feature_name() const {
  return *feature_name_;
}
inline void FeatureInfo::set_feature_name(const ::std::string& value) {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  feature_name_->assign(value);
}
inline void FeatureInfo::set_feature_name(const char* value) {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  feature_name_->assign(value);
}
inline void FeatureInfo::set_feature_name(const char* value, size_t size) {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  feature_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureInfo::mutable_feature_name() {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  return feature_name_;
}
inline ::std::string* FeatureInfo::release_feature_name() {
  clear_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feature_name_;
    feature_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .lbs.da.openservice.ScoreInfo score_info = 2;
inline bool FeatureInfo::has_score_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureInfo::set_has_score_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureInfo::clear_has_score_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureInfo::clear_score_info() {
  if (score_info_ != NULL) score_info_->::lbs::da::openservice::ScoreInfo::Clear();
  clear_has_score_info();
}
inline const ::lbs::da::openservice::ScoreInfo& FeatureInfo::score_info() const {
  return score_info_ != NULL ? *score_info_ : *default_instance_->score_info_;
}
inline ::lbs::da::openservice::ScoreInfo* FeatureInfo::mutable_score_info() {
  set_has_score_info();
  if (score_info_ == NULL) score_info_ = new ::lbs::da::openservice::ScoreInfo;
  return score_info_;
}
inline ::lbs::da::openservice::ScoreInfo* FeatureInfo::release_score_info() {
  clear_has_score_info();
  ::lbs::da::openservice::ScoreInfo* temp = score_info_;
  score_info_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.NuomiDataType data_type = 3;
inline bool FeatureInfo::has_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureInfo::set_has_data_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureInfo::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureInfo::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline lbs::da::openservice::NuomiDataType FeatureInfo::data_type() const {
  return static_cast< lbs::da::openservice::NuomiDataType >(data_type_);
}
inline void FeatureInfo::set_data_type(lbs::da::openservice::NuomiDataType value) {
  GOOGLE_DCHECK(lbs::da::openservice::NuomiDataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
}

// -------------------------------------------------------------------

// StrInfo

// required string featureid = 1;
inline bool StrInfo::has_featureid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrInfo::set_has_featureid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrInfo::clear_has_featureid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrInfo::clear_featureid() {
  if (featureid_ != &::google::protobuf::internal::kEmptyString) {
    featureid_->clear();
  }
  clear_has_featureid();
}
inline const ::std::string& StrInfo::featureid() const {
  return *featureid_;
}
inline void StrInfo::set_featureid(const ::std::string& value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void StrInfo::set_featureid(const char* value) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(value);
}
inline void StrInfo::set_featureid(const char* value, size_t size) {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  featureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrInfo::mutable_featureid() {
  set_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    featureid_ = new ::std::string;
  }
  return featureid_;
}
inline ::std::string* StrInfo::release_featureid() {
  clear_has_featureid();
  if (featureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = featureid_;
    featureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool StrInfo::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrInfo::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StrInfo::value() const {
  return *value_;
}
inline void StrInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StrInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StrInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* StrInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StrFeatureInfo

// required string feature_name = 1;
inline bool StrFeatureInfo::has_feature_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrFeatureInfo::set_has_feature_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrFeatureInfo::clear_has_feature_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrFeatureInfo::clear_feature_name() {
  if (feature_name_ != &::google::protobuf::internal::kEmptyString) {
    feature_name_->clear();
  }
  clear_has_feature_name();
}
inline const ::std::string& StrFeatureInfo::feature_name() const {
  return *feature_name_;
}
inline void StrFeatureInfo::set_feature_name(const ::std::string& value) {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  feature_name_->assign(value);
}
inline void StrFeatureInfo::set_feature_name(const char* value) {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  feature_name_->assign(value);
}
inline void StrFeatureInfo::set_feature_name(const char* value, size_t size) {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  feature_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrFeatureInfo::mutable_feature_name() {
  set_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    feature_name_ = new ::std::string;
  }
  return feature_name_;
}
inline ::std::string* StrFeatureInfo::release_feature_name() {
  clear_has_feature_name();
  if (feature_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feature_name_;
    feature_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .lbs.da.openservice.StrInfo str_info = 2;
inline bool StrFeatureInfo::has_str_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrFeatureInfo::set_has_str_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrFeatureInfo::clear_has_str_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrFeatureInfo::clear_str_info() {
  if (str_info_ != NULL) str_info_->::lbs::da::openservice::StrInfo::Clear();
  clear_has_str_info();
}
inline const ::lbs::da::openservice::StrInfo& StrFeatureInfo::str_info() const {
  return str_info_ != NULL ? *str_info_ : *default_instance_->str_info_;
}
inline ::lbs::da::openservice::StrInfo* StrFeatureInfo::mutable_str_info() {
  set_has_str_info();
  if (str_info_ == NULL) str_info_ = new ::lbs::da::openservice::StrInfo;
  return str_info_;
}
inline ::lbs::da::openservice::StrInfo* StrFeatureInfo::release_str_info() {
  clear_has_str_info();
  ::lbs::da::openservice::StrInfo* temp = str_info_;
  str_info_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.NuomiDataType data_type = 3;
inline bool StrFeatureInfo::has_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrFeatureInfo::set_has_data_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrFeatureInfo::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrFeatureInfo::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline lbs::da::openservice::NuomiDataType StrFeatureInfo::data_type() const {
  return static_cast< lbs::da::openservice::NuomiDataType >(data_type_);
}
inline void StrFeatureInfo::set_data_type(lbs::da::openservice::NuomiDataType value) {
  GOOGLE_DCHECK(lbs::da::openservice::NuomiDataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
}

// -------------------------------------------------------------------

// ItemUpInfo

// optional string id = 1;
inline bool ItemUpInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemUpInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemUpInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemUpInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ItemUpInfo::id() const {
  return *id_;
}
inline void ItemUpInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ItemUpInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ItemUpInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemUpInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ItemUpInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double score = 2;
inline bool ItemUpInfo::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemUpInfo::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemUpInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemUpInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double ItemUpInfo::score() const {
  return score_;
}
inline void ItemUpInfo::set_score(double value) {
  set_has_score();
  score_ = value;
}

// optional string info = 3;
inline bool ItemUpInfo::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemUpInfo::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemUpInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemUpInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ItemUpInfo::info() const {
  return *info_;
}
inline void ItemUpInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ItemUpInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ItemUpInfo::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemUpInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* ItemUpInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string date = 4;
inline bool ItemUpInfo::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemUpInfo::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemUpInfo::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemUpInfo::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& ItemUpInfo::date() const {
  return *date_;
}
inline void ItemUpInfo::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void ItemUpInfo::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void ItemUpInfo::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemUpInfo::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* ItemUpInfo::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NuomiUserPreferenceResponse

// repeated .lbs.da.openservice.FeatureInfo features = 1;
inline int NuomiUserPreferenceResponse::features_size() const {
  return features_.size();
}
inline void NuomiUserPreferenceResponse::clear_features() {
  features_.Clear();
}
inline const ::lbs::da::openservice::FeatureInfo& NuomiUserPreferenceResponse::features(int index) const {
  return features_.Get(index);
}
inline ::lbs::da::openservice::FeatureInfo* NuomiUserPreferenceResponse::mutable_features(int index) {
  return features_.Mutable(index);
}
inline ::lbs::da::openservice::FeatureInfo* NuomiUserPreferenceResponse::add_features() {
  return features_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::FeatureInfo >&
NuomiUserPreferenceResponse::features() const {
  return features_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::FeatureInfo >*
NuomiUserPreferenceResponse::mutable_features() {
  return &features_;
}

// optional .lbs.da.openservice.NuomiUpResultType result_type = 2;
inline bool NuomiUserPreferenceResponse::has_result_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NuomiUserPreferenceResponse::set_has_result_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NuomiUserPreferenceResponse::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NuomiUserPreferenceResponse::clear_result_type() {
  result_type_ = 1;
  clear_has_result_type();
}
inline lbs::da::openservice::NuomiUpResultType NuomiUserPreferenceResponse::result_type() const {
  return static_cast< lbs::da::openservice::NuomiUpResultType >(result_type_);
}
inline void NuomiUserPreferenceResponse::set_result_type(lbs::da::openservice::NuomiUpResultType value) {
  GOOGLE_DCHECK(lbs::da::openservice::NuomiUpResultType_IsValid(value));
  set_has_result_type();
  result_type_ = value;
}

// optional string id = 3;
inline bool NuomiUserPreferenceResponse::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NuomiUserPreferenceResponse::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NuomiUserPreferenceResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NuomiUserPreferenceResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NuomiUserPreferenceResponse::id() const {
  return *id_;
}
inline void NuomiUserPreferenceResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NuomiUserPreferenceResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NuomiUserPreferenceResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NuomiUserPreferenceResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* NuomiUserPreferenceResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .lbs.da.openservice.StrFeatureInfo other_infos = 4;
inline int NuomiUserPreferenceResponse::other_infos_size() const {
  return other_infos_.size();
}
inline void NuomiUserPreferenceResponse::clear_other_infos() {
  other_infos_.Clear();
}
inline const ::lbs::da::openservice::StrFeatureInfo& NuomiUserPreferenceResponse::other_infos(int index) const {
  return other_infos_.Get(index);
}
inline ::lbs::da::openservice::StrFeatureInfo* NuomiUserPreferenceResponse::mutable_other_infos(int index) {
  return other_infos_.Mutable(index);
}
inline ::lbs::da::openservice::StrFeatureInfo* NuomiUserPreferenceResponse::add_other_infos() {
  return other_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StrFeatureInfo >&
NuomiUserPreferenceResponse::other_infos() const {
  return other_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::StrFeatureInfo >*
NuomiUserPreferenceResponse::mutable_other_infos() {
  return &other_infos_;
}

// repeated .lbs.da.openservice.ItemUpInfo item_infos = 5;
inline int NuomiUserPreferenceResponse::item_infos_size() const {
  return item_infos_.size();
}
inline void NuomiUserPreferenceResponse::clear_item_infos() {
  item_infos_.Clear();
}
inline const ::lbs::da::openservice::ItemUpInfo& NuomiUserPreferenceResponse::item_infos(int index) const {
  return item_infos_.Get(index);
}
inline ::lbs::da::openservice::ItemUpInfo* NuomiUserPreferenceResponse::mutable_item_infos(int index) {
  return item_infos_.Mutable(index);
}
inline ::lbs::da::openservice::ItemUpInfo* NuomiUserPreferenceResponse::add_item_infos() {
  return item_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemUpInfo >&
NuomiUserPreferenceResponse::item_infos() const {
  return item_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::ItemUpInfo >*
NuomiUserPreferenceResponse::mutable_item_infos() {
  return &item_infos_;
}

// -------------------------------------------------------------------

// GetAOIRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetAOIRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAOIRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAOIRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAOIRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetAOIRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetAOIRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetAOIRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional string cuid = 2;
inline bool GetAOIRequest::has_cuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAOIRequest::set_has_cuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAOIRequest::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAOIRequest::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& GetAOIRequest::cuid() const {
  return *cuid_;
}
inline void GetAOIRequest::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetAOIRequest::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void GetAOIRequest::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAOIRequest::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* GetAOIRequest::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double mercator_x = 3;
inline bool GetAOIRequest::has_mercator_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAOIRequest::set_has_mercator_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAOIRequest::clear_has_mercator_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAOIRequest::clear_mercator_x() {
  mercator_x_ = 0;
  clear_has_mercator_x();
}
inline double GetAOIRequest::mercator_x() const {
  return mercator_x_;
}
inline void GetAOIRequest::set_mercator_x(double value) {
  set_has_mercator_x();
  mercator_x_ = value;
}

// optional double mercator_y = 4;
inline bool GetAOIRequest::has_mercator_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAOIRequest::set_has_mercator_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAOIRequest::clear_has_mercator_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAOIRequest::clear_mercator_y() {
  mercator_y_ = 0;
  clear_has_mercator_y();
}
inline double GetAOIRequest::mercator_y() const {
  return mercator_y_;
}
inline void GetAOIRequest::set_mercator_y(double value) {
  set_has_mercator_y();
  mercator_y_ = value;
}

// -------------------------------------------------------------------

// GetAOIResponse

// repeated string aoi_id = 1;
inline int GetAOIResponse::aoi_id_size() const {
  return aoi_id_.size();
}
inline void GetAOIResponse::clear_aoi_id() {
  aoi_id_.Clear();
}
inline const ::std::string& GetAOIResponse::aoi_id(int index) const {
  return aoi_id_.Get(index);
}
inline ::std::string* GetAOIResponse::mutable_aoi_id(int index) {
  return aoi_id_.Mutable(index);
}
inline void GetAOIResponse::set_aoi_id(int index, const ::std::string& value) {
  aoi_id_.Mutable(index)->assign(value);
}
inline void GetAOIResponse::set_aoi_id(int index, const char* value) {
  aoi_id_.Mutable(index)->assign(value);
}
inline void GetAOIResponse::set_aoi_id(int index, const char* value, size_t size) {
  aoi_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAOIResponse::add_aoi_id() {
  return aoi_id_.Add();
}
inline void GetAOIResponse::add_aoi_id(const ::std::string& value) {
  aoi_id_.Add()->assign(value);
}
inline void GetAOIResponse::add_aoi_id(const char* value) {
  aoi_id_.Add()->assign(value);
}
inline void GetAOIResponse::add_aoi_id(const char* value, size_t size) {
  aoi_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetAOIResponse::aoi_id() const {
  return aoi_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetAOIResponse::mutable_aoi_id() {
  return &aoi_id_;
}

// -------------------------------------------------------------------

// GetNearPoiRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool GetNearPoiRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNearPoiRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNearPoiRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNearPoiRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& GetNearPoiRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* GetNearPoiRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* GetNearPoiRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional double longitude = 2;
inline bool GetNearPoiRequest::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNearPoiRequest::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNearPoiRequest::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNearPoiRequest::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GetNearPoiRequest::longitude() const {
  return longitude_;
}
inline void GetNearPoiRequest::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 3;
inline bool GetNearPoiRequest::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetNearPoiRequest::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetNearPoiRequest::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetNearPoiRequest::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GetNearPoiRequest::latitude() const {
  return latitude_;
}
inline void GetNearPoiRequest::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double radius = 4;
inline bool GetNearPoiRequest::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetNearPoiRequest::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetNearPoiRequest::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetNearPoiRequest::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double GetNearPoiRequest::radius() const {
  return radius_;
}
inline void GetNearPoiRequest::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// PoiInfo

// optional string poi = 1;
inline bool PoiInfo::has_poi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoiInfo::set_has_poi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoiInfo::clear_has_poi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoiInfo::clear_poi() {
  if (poi_ != &::google::protobuf::internal::kEmptyString) {
    poi_->clear();
  }
  clear_has_poi();
}
inline const ::std::string& PoiInfo::poi() const {
  return *poi_;
}
inline void PoiInfo::set_poi(const ::std::string& value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void PoiInfo::set_poi(const char* value) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(value);
}
inline void PoiInfo::set_poi(const char* value, size_t size) {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  poi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiInfo::mutable_poi() {
  set_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    poi_ = new ::std::string;
  }
  return poi_;
}
inline ::std::string* PoiInfo::release_poi() {
  clear_has_poi();
  if (poi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_;
    poi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 2;
inline bool PoiInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoiInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoiInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoiInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PoiInfo::name() const {
  return *name_;
}
inline void PoiInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PoiInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PoiInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PoiInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double longitude = 3;
inline bool PoiInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoiInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoiInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoiInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double PoiInfo::longitude() const {
  return longitude_;
}
inline void PoiInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double latitude = 4;
inline bool PoiInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoiInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoiInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoiInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double PoiInfo::latitude() const {
  return latitude_;
}
inline void PoiInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// GetNearPoiResponse

// repeated .lbs.da.openservice.PoiInfo poi_list = 1;
inline int GetNearPoiResponse::poi_list_size() const {
  return poi_list_.size();
}
inline void GetNearPoiResponse::clear_poi_list() {
  poi_list_.Clear();
}
inline const ::lbs::da::openservice::PoiInfo& GetNearPoiResponse::poi_list(int index) const {
  return poi_list_.Get(index);
}
inline ::lbs::da::openservice::PoiInfo* GetNearPoiResponse::mutable_poi_list(int index) {
  return poi_list_.Mutable(index);
}
inline ::lbs::da::openservice::PoiInfo* GetNearPoiResponse::add_poi_list() {
  return poi_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >&
GetNearPoiResponse::poi_list() const {
  return poi_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::PoiInfo >*
GetNearPoiResponse::mutable_poi_list() {
  return &poi_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace openservice
}  // namespace da
}  // namespace lbs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::UserPreferenceSourceType>() {
  return lbs::da::openservice::UserPreferenceSourceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::UserTrajStatus>() {
  return lbs::da::openservice::UserTrajStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::RequestIdType>() {
  return lbs::da::openservice::RequestIdType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::NuomiDataType>() {
  return lbs::da::openservice::NuomiDataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::NuomiUpResultType>() {
  return lbs::da::openservice::NuomiUpResultType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pbrpc_2eproto__INCLUDED
