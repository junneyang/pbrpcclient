// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: regist_condition.proto

#ifndef PROTOBUF_regist_5fcondition_2eproto__INCLUDED
#define PROTOBUF_regist_5fcondition_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "pbrpc.pb.h"
// @@protoc_insertion_point(includes)

namespace lbs {
namespace da {
namespace openservice {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_regist_5fcondition_2eproto();
void protobuf_AssignDesc_regist_5fcondition_2eproto();
void protobuf_ShutdownFile_regist_5fcondition_2eproto();

class NameVal;
class LocationRule;
class TimeRule;
class SourceRule;
class TrajStatusRule;
class IsStayRule;
class PoiRule;
class AoiRule;
class StrMatchRule;
class Rule;
class Condition;
class RegistInfo;
class RegistConditionRequest;
class RegistConditionResponse;
class Trigger;
class SetTriggerRequest;
class SetTriggerResponse;

enum RuleType {
  LOCATION_RULE = 1,
  TIME_RULE = 2,
  SOURCE_RULE = 3,
  TRAJSTATUS_RULE = 4,
  ISSTAY_RULE = 5,
  POI_RULE = 6,
  AOI_RULE = 7,
  STRMATCH_RULE = 8
};
bool RuleType_IsValid(int value);
const RuleType RuleType_MIN = LOCATION_RULE;
const RuleType RuleType_MAX = STRMATCH_RULE;
const int RuleType_ARRAYSIZE = RuleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RuleType_descriptor();
inline const ::std::string& RuleType_Name(RuleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RuleType_descriptor(), value);
}
inline bool RuleType_Parse(
    const ::std::string& name, RuleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RuleType>(
    RuleType_descriptor(), name, value);
}
enum Operation {
  TO_ADD = 1,
  TO_DELETE = 2,
  TO_DELETE_BY_USER_TAG = 3,
  TO_DELETE_BY_POI_TAG = 4
};
bool Operation_IsValid(int value);
const Operation Operation_MIN = TO_ADD;
const Operation Operation_MAX = TO_DELETE_BY_POI_TAG;
const int Operation_ARRAYSIZE = Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_descriptor();
inline const ::std::string& Operation_Name(Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_descriptor(), value);
}
inline bool Operation_Parse(
    const ::std::string& name, Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation>(
    Operation_descriptor(), name, value);
}
// ===================================================================

class NameVal : public ::google::protobuf::Message {
 public:
  NameVal();
  virtual ~NameVal();
  
  NameVal(const NameVal& from);
  
  inline NameVal& operator=(const NameVal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NameVal& default_instance();
  
  void Swap(NameVal* other);
  
  // implements Message ----------------------------------------------
  
  NameVal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameVal& from);
  void MergeFrom(const NameVal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.NameVal)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static NameVal* default_instance_;
};
// -------------------------------------------------------------------

class LocationRule : public ::google::protobuf::Message {
 public:
  LocationRule();
  virtual ~LocationRule();
  
  LocationRule(const LocationRule& from);
  
  inline LocationRule& operator=(const LocationRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationRule& default_instance();
  
  void Swap(LocationRule* other);
  
  // implements Message ----------------------------------------------
  
  LocationRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocationRule& from);
  void MergeFrom(const LocationRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline double r() const;
  inline void set_r(double value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.LocationRule)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_r();
  inline void clear_has_r();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double r_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static LocationRule* default_instance_;
};
// -------------------------------------------------------------------

class TimeRule : public ::google::protobuf::Message {
 public:
  TimeRule();
  virtual ~TimeRule();
  
  TimeRule(const TimeRule& from);
  
  inline TimeRule& operator=(const TimeRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeRule& default_instance();
  
  void Swap(TimeRule* other);
  
  // implements Message ----------------------------------------------
  
  TimeRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeRule& from);
  void MergeFrom(const TimeRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 t = 1;
  inline bool has_t() const;
  inline void clear_t();
  static const int kTFieldNumber = 1;
  inline ::google::protobuf::int32 t() const;
  inline void set_t(::google::protobuf::int32 value);
  
  // optional int32 range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline ::google::protobuf::int32 range() const;
  inline void set_range(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.TimeRule)
 private:
  inline void set_has_t();
  inline void clear_has_t();
  inline void set_has_range();
  inline void clear_has_range();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 t_;
  ::google::protobuf::int32 range_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static TimeRule* default_instance_;
};
// -------------------------------------------------------------------

class SourceRule : public ::google::protobuf::Message {
 public:
  SourceRule();
  virtual ~SourceRule();
  
  SourceRule(const SourceRule& from);
  
  inline SourceRule& operator=(const SourceRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SourceRule& default_instance();
  
  void Swap(SourceRule* other);
  
  // implements Message ----------------------------------------------
  
  SourceRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SourceRule& from);
  void MergeFrom(const SourceRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string source = 1;
  inline int source_size() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source(int index) const;
  inline ::std::string* mutable_source(int index);
  inline void set_source(int index, const ::std::string& value);
  inline void set_source(int index, const char* value);
  inline void set_source(int index, const char* value, size_t size);
  inline ::std::string* add_source();
  inline void add_source(const ::std::string& value);
  inline void add_source(const char* value);
  inline void add_source(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& source() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_source();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.SourceRule)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> source_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static SourceRule* default_instance_;
};
// -------------------------------------------------------------------

class TrajStatusRule : public ::google::protobuf::Message {
 public:
  TrajStatusRule();
  virtual ~TrajStatusRule();
  
  TrajStatusRule(const TrajStatusRule& from);
  
  inline TrajStatusRule& operator=(const TrajStatusRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajStatusRule& default_instance();
  
  void Swap(TrajStatusRule* other);
  
  // implements Message ----------------------------------------------
  
  TrajStatusRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrajStatusRule& from);
  void MergeFrom(const TrajStatusRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.UserTrajStatus traj_status = 1;
  inline int traj_status_size() const;
  inline void clear_traj_status();
  static const int kTrajStatusFieldNumber = 1;
  inline lbs::da::openservice::UserTrajStatus traj_status(int index) const;
  inline void set_traj_status(int index, lbs::da::openservice::UserTrajStatus value);
  inline void add_traj_status(lbs::da::openservice::UserTrajStatus value);
  inline const ::google::protobuf::RepeatedField<int>& traj_status() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_traj_status();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.TrajStatusRule)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField<int> traj_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static TrajStatusRule* default_instance_;
};
// -------------------------------------------------------------------

class IsStayRule : public ::google::protobuf::Message {
 public:
  IsStayRule();
  virtual ~IsStayRule();
  
  IsStayRule(const IsStayRule& from);
  
  inline IsStayRule& operator=(const IsStayRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsStayRule& default_instance();
  
  void Swap(IsStayRule* other);
  
  // implements Message ----------------------------------------------
  
  IsStayRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsStayRule& from);
  void MergeFrom(const IsStayRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool is_stay = 1;
  inline bool has_is_stay() const;
  inline void clear_is_stay();
  static const int kIsStayFieldNumber = 1;
  inline bool is_stay() const;
  inline void set_is_stay(bool value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.IsStayRule)
 private:
  inline void set_has_is_stay();
  inline void clear_has_is_stay();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool is_stay_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static IsStayRule* default_instance_;
};
// -------------------------------------------------------------------

class PoiRule : public ::google::protobuf::Message {
 public:
  PoiRule();
  virtual ~PoiRule();
  
  PoiRule(const PoiRule& from);
  
  inline PoiRule& operator=(const PoiRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoiRule& default_instance();
  
  void Swap(PoiRule* other);
  
  // implements Message ----------------------------------------------
  
  PoiRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoiRule& from);
  void MergeFrom(const PoiRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string poi_id = 1;
  inline bool has_poi_id() const;
  inline void clear_poi_id();
  static const int kPoiIdFieldNumber = 1;
  inline const ::std::string& poi_id() const;
  inline void set_poi_id(const ::std::string& value);
  inline void set_poi_id(const char* value);
  inline void set_poi_id(const char* value, size_t size);
  inline ::std::string* mutable_poi_id();
  inline ::std::string* release_poi_id();
  
  // optional double poi_x = 2;
  inline bool has_poi_x() const;
  inline void clear_poi_x();
  static const int kPoiXFieldNumber = 2;
  inline double poi_x() const;
  inline void set_poi_x(double value);
  
  // optional double poi_y = 3;
  inline bool has_poi_y() const;
  inline void clear_poi_y();
  static const int kPoiYFieldNumber = 3;
  inline double poi_y() const;
  inline void set_poi_y(double value);
  
  // optional double poi_r = 4;
  inline bool has_poi_r() const;
  inline void clear_poi_r();
  static const int kPoiRFieldNumber = 4;
  inline double poi_r() const;
  inline void set_poi_r(double value);
  
  // optional string poi_tag = 5;
  inline bool has_poi_tag() const;
  inline void clear_poi_tag();
  static const int kPoiTagFieldNumber = 5;
  inline const ::std::string& poi_tag() const;
  inline void set_poi_tag(const ::std::string& value);
  inline void set_poi_tag(const char* value);
  inline void set_poi_tag(const char* value, size_t size);
  inline ::std::string* mutable_poi_tag();
  inline ::std::string* release_poi_tag();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.PoiRule)
 private:
  inline void set_has_poi_id();
  inline void clear_has_poi_id();
  inline void set_has_poi_x();
  inline void clear_has_poi_x();
  inline void set_has_poi_y();
  inline void clear_has_poi_y();
  inline void set_has_poi_r();
  inline void clear_has_poi_r();
  inline void set_has_poi_tag();
  inline void clear_has_poi_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* poi_id_;
  double poi_x_;
  double poi_y_;
  double poi_r_;
  ::std::string* poi_tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static PoiRule* default_instance_;
};
// -------------------------------------------------------------------

class AoiRule : public ::google::protobuf::Message {
 public:
  AoiRule();
  virtual ~AoiRule();
  
  AoiRule(const AoiRule& from);
  
  inline AoiRule& operator=(const AoiRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AoiRule& default_instance();
  
  void Swap(AoiRule* other);
  
  // implements Message ----------------------------------------------
  
  AoiRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AoiRule& from);
  void MergeFrom(const AoiRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string aoi_id = 1;
  inline bool has_aoi_id() const;
  inline void clear_aoi_id();
  static const int kAoiIdFieldNumber = 1;
  inline const ::std::string& aoi_id() const;
  inline void set_aoi_id(const ::std::string& value);
  inline void set_aoi_id(const char* value);
  inline void set_aoi_id(const char* value, size_t size);
  inline ::std::string* mutable_aoi_id();
  inline ::std::string* release_aoi_id();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.AoiRule)
 private:
  inline void set_has_aoi_id();
  inline void clear_has_aoi_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* aoi_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static AoiRule* default_instance_;
};
// -------------------------------------------------------------------

class StrMatchRule : public ::google::protobuf::Message {
 public:
  StrMatchRule();
  virtual ~StrMatchRule();
  
  StrMatchRule(const StrMatchRule& from);
  
  inline StrMatchRule& operator=(const StrMatchRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrMatchRule& default_instance();
  
  void Swap(StrMatchRule* other);
  
  // implements Message ----------------------------------------------
  
  StrMatchRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrMatchRule& from);
  void MergeFrom(const StrMatchRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.NameVal str_rules = 1;
  inline int str_rules_size() const;
  inline void clear_str_rules();
  static const int kStrRulesFieldNumber = 1;
  inline const ::lbs::da::openservice::NameVal& str_rules(int index) const;
  inline ::lbs::da::openservice::NameVal* mutable_str_rules(int index);
  inline ::lbs::da::openservice::NameVal* add_str_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::NameVal >&
      str_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::NameVal >*
      mutable_str_rules();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.StrMatchRule)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::NameVal > str_rules_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static StrMatchRule* default_instance_;
};
// -------------------------------------------------------------------

class Rule : public ::google::protobuf::Message {
 public:
  Rule();
  virtual ~Rule();
  
  Rule(const Rule& from);
  
  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rule& default_instance();
  
  void Swap(Rule* other);
  
  // implements Message ----------------------------------------------
  
  Rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rule& from);
  void MergeFrom(const Rule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RuleType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline lbs::da::openservice::RuleType type() const;
  inline void set_type(lbs::da::openservice::RuleType value);
  
  // optional .lbs.da.openservice.LocationRule location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::lbs::da::openservice::LocationRule& location() const;
  inline ::lbs::da::openservice::LocationRule* mutable_location();
  inline ::lbs::da::openservice::LocationRule* release_location();
  
  // optional .lbs.da.openservice.TimeRule time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::lbs::da::openservice::TimeRule& time() const;
  inline ::lbs::da::openservice::TimeRule* mutable_time();
  inline ::lbs::da::openservice::TimeRule* release_time();
  
  // optional .lbs.da.openservice.SourceRule source = 4;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 4;
  inline const ::lbs::da::openservice::SourceRule& source() const;
  inline ::lbs::da::openservice::SourceRule* mutable_source();
  inline ::lbs::da::openservice::SourceRule* release_source();
  
  // optional .lbs.da.openservice.TrajStatusRule traj_status = 5;
  inline bool has_traj_status() const;
  inline void clear_traj_status();
  static const int kTrajStatusFieldNumber = 5;
  inline const ::lbs::da::openservice::TrajStatusRule& traj_status() const;
  inline ::lbs::da::openservice::TrajStatusRule* mutable_traj_status();
  inline ::lbs::da::openservice::TrajStatusRule* release_traj_status();
  
  // optional .lbs.da.openservice.IsStayRule is_stay = 6;
  inline bool has_is_stay() const;
  inline void clear_is_stay();
  static const int kIsStayFieldNumber = 6;
  inline const ::lbs::da::openservice::IsStayRule& is_stay() const;
  inline ::lbs::da::openservice::IsStayRule* mutable_is_stay();
  inline ::lbs::da::openservice::IsStayRule* release_is_stay();
  
  // optional .lbs.da.openservice.PoiRule poi = 7;
  inline bool has_poi() const;
  inline void clear_poi();
  static const int kPoiFieldNumber = 7;
  inline const ::lbs::da::openservice::PoiRule& poi() const;
  inline ::lbs::da::openservice::PoiRule* mutable_poi();
  inline ::lbs::da::openservice::PoiRule* release_poi();
  
  // optional .lbs.da.openservice.AoiRule aoi = 8;
  inline bool has_aoi() const;
  inline void clear_aoi();
  static const int kAoiFieldNumber = 8;
  inline const ::lbs::da::openservice::AoiRule& aoi() const;
  inline ::lbs::da::openservice::AoiRule* mutable_aoi();
  inline ::lbs::da::openservice::AoiRule* release_aoi();
  
  // optional .lbs.da.openservice.StrMatchRule str_rule = 100;
  inline bool has_str_rule() const;
  inline void clear_str_rule();
  static const int kStrRuleFieldNumber = 100;
  inline const ::lbs::da::openservice::StrMatchRule& str_rule() const;
  inline ::lbs::da::openservice::StrMatchRule* mutable_str_rule();
  inline ::lbs::da::openservice::StrMatchRule* release_str_rule();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.Rule)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_traj_status();
  inline void clear_has_traj_status();
  inline void set_has_is_stay();
  inline void clear_has_is_stay();
  inline void set_has_poi();
  inline void clear_has_poi();
  inline void set_has_aoi();
  inline void clear_has_aoi();
  inline void set_has_str_rule();
  inline void clear_has_str_rule();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::LocationRule* location_;
  ::lbs::da::openservice::TimeRule* time_;
  ::lbs::da::openservice::SourceRule* source_;
  ::lbs::da::openservice::TrajStatusRule* traj_status_;
  ::lbs::da::openservice::IsStayRule* is_stay_;
  ::lbs::da::openservice::PoiRule* poi_;
  ::lbs::da::openservice::AoiRule* aoi_;
  ::lbs::da::openservice::StrMatchRule* str_rule_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static Rule* default_instance_;
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message {
 public:
  Condition();
  virtual ~Condition();
  
  Condition(const Condition& from);
  
  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();
  
  void Swap(Condition* other);
  
  // implements Message ----------------------------------------------
  
  Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .lbs.da.openservice.Rule rules = 1;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 1;
  inline const ::lbs::da::openservice::Rule& rules(int index) const;
  inline ::lbs::da::openservice::Rule* mutable_rules(int index);
  inline ::lbs::da::openservice::Rule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >*
      mutable_rules();
  
  // optional string append = 2;
  inline bool has_append() const;
  inline void clear_append();
  static const int kAppendFieldNumber = 2;
  inline const ::std::string& append() const;
  inline void set_append(const ::std::string& value);
  inline void set_append(const char* value);
  inline void set_append(const char* value, size_t size);
  inline ::std::string* mutable_append();
  inline ::std::string* release_append();
  
  // optional string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.Condition)
 private:
  inline void set_has_append();
  inline void clear_has_append();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule > rules_;
  ::std::string* append_;
  ::std::string* tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static Condition* default_instance_;
};
// -------------------------------------------------------------------

class RegistInfo : public ::google::protobuf::Message {
 public:
  RegistInfo();
  virtual ~RegistInfo();
  
  RegistInfo(const RegistInfo& from);
  
  inline RegistInfo& operator=(const RegistInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistInfo& default_instance();
  
  void Swap(RegistInfo* other);
  
  // implements Message ----------------------------------------------
  
  RegistInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistInfo& from);
  void MergeFrom(const RegistInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string cuid = 1;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 1;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  
  // optional .lbs.da.openservice.Condition cond = 2;
  inline bool has_cond() const;
  inline void clear_cond();
  static const int kCondFieldNumber = 2;
  inline const ::lbs::da::openservice::Condition& cond() const;
  inline ::lbs::da::openservice::Condition* mutable_cond();
  inline ::lbs::da::openservice::Condition* release_cond();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.RegistInfo)
 private:
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_cond();
  inline void clear_has_cond();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cuid_;
  ::lbs::da::openservice::Condition* cond_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static RegistInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegistConditionRequest : public ::google::protobuf::Message {
 public:
  RegistConditionRequest();
  virtual ~RegistConditionRequest();
  
  RegistConditionRequest(const RegistConditionRequest& from);
  
  inline RegistConditionRequest& operator=(const RegistConditionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistConditionRequest& default_instance();
  
  void Swap(RegistConditionRequest* other);
  
  // implements Message ----------------------------------------------
  
  RegistConditionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistConditionRequest& from);
  void MergeFrom(const RegistConditionRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // repeated .lbs.da.openservice.RegistInfo regist_info = 2;
  inline int regist_info_size() const;
  inline void clear_regist_info();
  static const int kRegistInfoFieldNumber = 2;
  inline const ::lbs::da::openservice::RegistInfo& regist_info(int index) const;
  inline ::lbs::da::openservice::RegistInfo* mutable_regist_info(int index);
  inline ::lbs::da::openservice::RegistInfo* add_regist_info();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegistInfo >&
      regist_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegistInfo >*
      mutable_regist_info();
  
  // required .lbs.da.openservice.Operation operation = 3;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 3;
  inline lbs::da::openservice::Operation operation() const;
  inline void set_operation(lbs::da::openservice::Operation value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.RegistConditionRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_operation();
  inline void clear_has_operation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegistInfo > regist_info_;
  int operation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static RegistConditionRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegistConditionResponse : public ::google::protobuf::Message {
 public:
  RegistConditionResponse();
  virtual ~RegistConditionResponse();
  
  RegistConditionResponse(const RegistConditionResponse& from);
  
  inline RegistConditionResponse& operator=(const RegistConditionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistConditionResponse& default_instance();
  
  void Swap(RegistConditionResponse* other);
  
  // implements Message ----------------------------------------------
  
  RegistConditionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistConditionResponse& from);
  void MergeFrom(const RegistConditionResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool is_success = 1;
  inline bool has_is_success() const;
  inline void clear_is_success();
  static const int kIsSuccessFieldNumber = 1;
  inline bool is_success() const;
  inline void set_is_success(bool value);
  
  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.RegistConditionResponse)
 private:
  inline void set_has_is_success();
  inline void clear_has_is_success();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool is_success_;
  ::google::protobuf::int32 num_;
  ::std::string* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static RegistConditionResponse* default_instance_;
};
// -------------------------------------------------------------------

class Trigger : public ::google::protobuf::Message {
 public:
  Trigger();
  virtual ~Trigger();
  
  Trigger(const Trigger& from);
  
  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger& default_instance();
  
  void Swap(Trigger* other);
  
  // implements Message ----------------------------------------------
  
  Trigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // optional string post_url = 2;
  inline bool has_post_url() const;
  inline void clear_post_url();
  static const int kPostUrlFieldNumber = 2;
  inline const ::std::string& post_url() const;
  inline void set_post_url(const ::std::string& value);
  inline void set_post_url(const char* value);
  inline void set_post_url(const char* value, size_t size);
  inline ::std::string* mutable_post_url();
  inline ::std::string* release_post_url();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.Trigger)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_post_url();
  inline void clear_has_post_url();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* tag_;
  ::std::string* post_url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// -------------------------------------------------------------------

class SetTriggerRequest : public ::google::protobuf::Message {
 public:
  SetTriggerRequest();
  virtual ~SetTriggerRequest();
  
  SetTriggerRequest(const SetTriggerRequest& from);
  
  inline SetTriggerRequest& operator=(const SetTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTriggerRequest& default_instance();
  
  void Swap(SetTriggerRequest* other);
  
  // implements Message ----------------------------------------------
  
  SetTriggerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTriggerRequest& from);
  void MergeFrom(const SetTriggerRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .lbs.da.openservice.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::lbs::da::openservice::RequestHeader& header() const;
  inline ::lbs::da::openservice::RequestHeader* mutable_header();
  inline ::lbs::da::openservice::RequestHeader* release_header();
  
  // repeated .lbs.da.openservice.Trigger trigger = 2;
  inline int trigger_size() const;
  inline void clear_trigger();
  static const int kTriggerFieldNumber = 2;
  inline const ::lbs::da::openservice::Trigger& trigger(int index) const;
  inline ::lbs::da::openservice::Trigger* mutable_trigger(int index);
  inline ::lbs::da::openservice::Trigger* add_trigger();
  inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Trigger >&
      trigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Trigger >*
      mutable_trigger();
  
  // required .lbs.da.openservice.Operation operation = 3;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 3;
  inline lbs::da::openservice::Operation operation() const;
  inline void set_operation(lbs::da::openservice::Operation value);
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.SetTriggerRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_operation();
  inline void clear_has_operation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::lbs::da::openservice::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Trigger > trigger_;
  int operation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static SetTriggerRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetTriggerResponse : public ::google::protobuf::Message {
 public:
  SetTriggerResponse();
  virtual ~SetTriggerResponse();
  
  SetTriggerResponse(const SetTriggerResponse& from);
  
  inline SetTriggerResponse& operator=(const SetTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTriggerResponse& default_instance();
  
  void Swap(SetTriggerResponse* other);
  
  // implements Message ----------------------------------------------
  
  SetTriggerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTriggerResponse& from);
  void MergeFrom(const SetTriggerResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool is_success = 1;
  inline bool has_is_success() const;
  inline void clear_is_success();
  static const int kIsSuccessFieldNumber = 1;
  inline bool is_success() const;
  inline void set_is_success(bool value);
  
  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // @@protoc_insertion_point(class_scope:lbs.da.openservice.SetTriggerResponse)
 private:
  inline void set_has_is_success();
  inline void clear_has_is_success();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool is_success_;
  ::google::protobuf::int32 num_;
  ::std::string* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_regist_5fcondition_2eproto();
  friend void protobuf_AssignDesc_regist_5fcondition_2eproto();
  friend void protobuf_ShutdownFile_regist_5fcondition_2eproto();
  
  void InitAsDefaultInstance();
  static SetTriggerResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// NameVal

// optional string name = 1;
inline bool NameVal::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameVal::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameVal::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameVal::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameVal::name() const {
  return *name_;
}
inline void NameVal::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameVal::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameVal::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameVal::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameVal::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 2;
inline bool NameVal::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameVal::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameVal::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameVal::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameVal::value() const {
  return *value_;
}
inline void NameVal::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameVal::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameVal::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameVal::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameVal::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LocationRule

// optional double x = 1;
inline bool LocationRule::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationRule::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationRule::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationRule::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double LocationRule::x() const {
  return x_;
}
inline void LocationRule::set_x(double value) {
  set_has_x();
  x_ = value;
}

// optional double y = 2;
inline bool LocationRule::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationRule::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationRule::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationRule::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double LocationRule::y() const {
  return y_;
}
inline void LocationRule::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double r = 3;
inline bool LocationRule::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationRule::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationRule::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationRule::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline double LocationRule::r() const {
  return r_;
}
inline void LocationRule::set_r(double value) {
  set_has_r();
  r_ = value;
}

// -------------------------------------------------------------------

// TimeRule

// optional int32 t = 1;
inline bool TimeRule::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeRule::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeRule::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeRule::clear_t() {
  t_ = 0;
  clear_has_t();
}
inline ::google::protobuf::int32 TimeRule::t() const {
  return t_;
}
inline void TimeRule::set_t(::google::protobuf::int32 value) {
  set_has_t();
  t_ = value;
}

// optional int32 range = 2;
inline bool TimeRule::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeRule::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeRule::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeRule::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline ::google::protobuf::int32 TimeRule::range() const {
  return range_;
}
inline void TimeRule::set_range(::google::protobuf::int32 value) {
  set_has_range();
  range_ = value;
}

// -------------------------------------------------------------------

// SourceRule

// repeated string source = 1;
inline int SourceRule::source_size() const {
  return source_.size();
}
inline void SourceRule::clear_source() {
  source_.Clear();
}
inline const ::std::string& SourceRule::source(int index) const {
  return source_.Get(index);
}
inline ::std::string* SourceRule::mutable_source(int index) {
  return source_.Mutable(index);
}
inline void SourceRule::set_source(int index, const ::std::string& value) {
  source_.Mutable(index)->assign(value);
}
inline void SourceRule::set_source(int index, const char* value) {
  source_.Mutable(index)->assign(value);
}
inline void SourceRule::set_source(int index, const char* value, size_t size) {
  source_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SourceRule::add_source() {
  return source_.Add();
}
inline void SourceRule::add_source(const ::std::string& value) {
  source_.Add()->assign(value);
}
inline void SourceRule::add_source(const char* value) {
  source_.Add()->assign(value);
}
inline void SourceRule::add_source(const char* value, size_t size) {
  source_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SourceRule::source() const {
  return source_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SourceRule::mutable_source() {
  return &source_;
}

// -------------------------------------------------------------------

// TrajStatusRule

// repeated .lbs.da.openservice.UserTrajStatus traj_status = 1;
inline int TrajStatusRule::traj_status_size() const {
  return traj_status_.size();
}
inline void TrajStatusRule::clear_traj_status() {
  traj_status_.Clear();
}
inline lbs::da::openservice::UserTrajStatus TrajStatusRule::traj_status(int index) const {
  return static_cast< lbs::da::openservice::UserTrajStatus >(traj_status_.Get(index));
}
inline void TrajStatusRule::set_traj_status(int index, lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  traj_status_.Set(index, value);
}
inline void TrajStatusRule::add_traj_status(lbs::da::openservice::UserTrajStatus value) {
  GOOGLE_DCHECK(lbs::da::openservice::UserTrajStatus_IsValid(value));
  traj_status_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TrajStatusRule::traj_status() const {
  return traj_status_;
}
inline ::google::protobuf::RepeatedField<int>*
TrajStatusRule::mutable_traj_status() {
  return &traj_status_;
}

// -------------------------------------------------------------------

// IsStayRule

// optional bool is_stay = 1;
inline bool IsStayRule::has_is_stay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsStayRule::set_has_is_stay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsStayRule::clear_has_is_stay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsStayRule::clear_is_stay() {
  is_stay_ = false;
  clear_has_is_stay();
}
inline bool IsStayRule::is_stay() const {
  return is_stay_;
}
inline void IsStayRule::set_is_stay(bool value) {
  set_has_is_stay();
  is_stay_ = value;
}

// -------------------------------------------------------------------

// PoiRule

// optional string poi_id = 1;
inline bool PoiRule::has_poi_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoiRule::set_has_poi_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoiRule::clear_has_poi_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoiRule::clear_poi_id() {
  if (poi_id_ != &::google::protobuf::internal::kEmptyString) {
    poi_id_->clear();
  }
  clear_has_poi_id();
}
inline const ::std::string& PoiRule::poi_id() const {
  return *poi_id_;
}
inline void PoiRule::set_poi_id(const ::std::string& value) {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  poi_id_->assign(value);
}
inline void PoiRule::set_poi_id(const char* value) {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  poi_id_->assign(value);
}
inline void PoiRule::set_poi_id(const char* value, size_t size) {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  poi_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiRule::mutable_poi_id() {
  set_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    poi_id_ = new ::std::string;
  }
  return poi_id_;
}
inline ::std::string* PoiRule::release_poi_id() {
  clear_has_poi_id();
  if (poi_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_id_;
    poi_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double poi_x = 2;
inline bool PoiRule::has_poi_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoiRule::set_has_poi_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoiRule::clear_has_poi_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoiRule::clear_poi_x() {
  poi_x_ = 0;
  clear_has_poi_x();
}
inline double PoiRule::poi_x() const {
  return poi_x_;
}
inline void PoiRule::set_poi_x(double value) {
  set_has_poi_x();
  poi_x_ = value;
}

// optional double poi_y = 3;
inline bool PoiRule::has_poi_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoiRule::set_has_poi_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoiRule::clear_has_poi_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoiRule::clear_poi_y() {
  poi_y_ = 0;
  clear_has_poi_y();
}
inline double PoiRule::poi_y() const {
  return poi_y_;
}
inline void PoiRule::set_poi_y(double value) {
  set_has_poi_y();
  poi_y_ = value;
}

// optional double poi_r = 4;
inline bool PoiRule::has_poi_r() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoiRule::set_has_poi_r() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoiRule::clear_has_poi_r() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoiRule::clear_poi_r() {
  poi_r_ = 0;
  clear_has_poi_r();
}
inline double PoiRule::poi_r() const {
  return poi_r_;
}
inline void PoiRule::set_poi_r(double value) {
  set_has_poi_r();
  poi_r_ = value;
}

// optional string poi_tag = 5;
inline bool PoiRule::has_poi_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoiRule::set_has_poi_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoiRule::clear_has_poi_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoiRule::clear_poi_tag() {
  if (poi_tag_ != &::google::protobuf::internal::kEmptyString) {
    poi_tag_->clear();
  }
  clear_has_poi_tag();
}
inline const ::std::string& PoiRule::poi_tag() const {
  return *poi_tag_;
}
inline void PoiRule::set_poi_tag(const ::std::string& value) {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  poi_tag_->assign(value);
}
inline void PoiRule::set_poi_tag(const char* value) {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  poi_tag_->assign(value);
}
inline void PoiRule::set_poi_tag(const char* value, size_t size) {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  poi_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoiRule::mutable_poi_tag() {
  set_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    poi_tag_ = new ::std::string;
  }
  return poi_tag_;
}
inline ::std::string* PoiRule::release_poi_tag() {
  clear_has_poi_tag();
  if (poi_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = poi_tag_;
    poi_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AoiRule

// optional string aoi_id = 1;
inline bool AoiRule::has_aoi_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AoiRule::set_has_aoi_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AoiRule::clear_has_aoi_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AoiRule::clear_aoi_id() {
  if (aoi_id_ != &::google::protobuf::internal::kEmptyString) {
    aoi_id_->clear();
  }
  clear_has_aoi_id();
}
inline const ::std::string& AoiRule::aoi_id() const {
  return *aoi_id_;
}
inline void AoiRule::set_aoi_id(const ::std::string& value) {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  aoi_id_->assign(value);
}
inline void AoiRule::set_aoi_id(const char* value) {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  aoi_id_->assign(value);
}
inline void AoiRule::set_aoi_id(const char* value, size_t size) {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  aoi_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AoiRule::mutable_aoi_id() {
  set_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    aoi_id_ = new ::std::string;
  }
  return aoi_id_;
}
inline ::std::string* AoiRule::release_aoi_id() {
  clear_has_aoi_id();
  if (aoi_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = aoi_id_;
    aoi_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StrMatchRule

// repeated .lbs.da.openservice.NameVal str_rules = 1;
inline int StrMatchRule::str_rules_size() const {
  return str_rules_.size();
}
inline void StrMatchRule::clear_str_rules() {
  str_rules_.Clear();
}
inline const ::lbs::da::openservice::NameVal& StrMatchRule::str_rules(int index) const {
  return str_rules_.Get(index);
}
inline ::lbs::da::openservice::NameVal* StrMatchRule::mutable_str_rules(int index) {
  return str_rules_.Mutable(index);
}
inline ::lbs::da::openservice::NameVal* StrMatchRule::add_str_rules() {
  return str_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::NameVal >&
StrMatchRule::str_rules() const {
  return str_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::NameVal >*
StrMatchRule::mutable_str_rules() {
  return &str_rules_;
}

// -------------------------------------------------------------------

// Rule

// required .lbs.da.openservice.RuleType type = 1;
inline bool Rule::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rule::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rule::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rule::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline lbs::da::openservice::RuleType Rule::type() const {
  return static_cast< lbs::da::openservice::RuleType >(type_);
}
inline void Rule::set_type(lbs::da::openservice::RuleType value) {
  GOOGLE_DCHECK(lbs::da::openservice::RuleType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .lbs.da.openservice.LocationRule location = 2;
inline bool Rule::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rule::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rule::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rule::clear_location() {
  if (location_ != NULL) location_->::lbs::da::openservice::LocationRule::Clear();
  clear_has_location();
}
inline const ::lbs::da::openservice::LocationRule& Rule::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::lbs::da::openservice::LocationRule* Rule::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::lbs::da::openservice::LocationRule;
  return location_;
}
inline ::lbs::da::openservice::LocationRule* Rule::release_location() {
  clear_has_location();
  ::lbs::da::openservice::LocationRule* temp = location_;
  location_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.TimeRule time = 3;
inline bool Rule::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rule::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rule::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rule::clear_time() {
  if (time_ != NULL) time_->::lbs::da::openservice::TimeRule::Clear();
  clear_has_time();
}
inline const ::lbs::da::openservice::TimeRule& Rule::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::lbs::da::openservice::TimeRule* Rule::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::lbs::da::openservice::TimeRule;
  return time_;
}
inline ::lbs::da::openservice::TimeRule* Rule::release_time() {
  clear_has_time();
  ::lbs::da::openservice::TimeRule* temp = time_;
  time_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.SourceRule source = 4;
inline bool Rule::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rule::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rule::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rule::clear_source() {
  if (source_ != NULL) source_->::lbs::da::openservice::SourceRule::Clear();
  clear_has_source();
}
inline const ::lbs::da::openservice::SourceRule& Rule::source() const {
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::lbs::da::openservice::SourceRule* Rule::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::lbs::da::openservice::SourceRule;
  return source_;
}
inline ::lbs::da::openservice::SourceRule* Rule::release_source() {
  clear_has_source();
  ::lbs::da::openservice::SourceRule* temp = source_;
  source_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.TrajStatusRule traj_status = 5;
inline bool Rule::has_traj_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Rule::set_has_traj_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Rule::clear_has_traj_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Rule::clear_traj_status() {
  if (traj_status_ != NULL) traj_status_->::lbs::da::openservice::TrajStatusRule::Clear();
  clear_has_traj_status();
}
inline const ::lbs::da::openservice::TrajStatusRule& Rule::traj_status() const {
  return traj_status_ != NULL ? *traj_status_ : *default_instance_->traj_status_;
}
inline ::lbs::da::openservice::TrajStatusRule* Rule::mutable_traj_status() {
  set_has_traj_status();
  if (traj_status_ == NULL) traj_status_ = new ::lbs::da::openservice::TrajStatusRule;
  return traj_status_;
}
inline ::lbs::da::openservice::TrajStatusRule* Rule::release_traj_status() {
  clear_has_traj_status();
  ::lbs::da::openservice::TrajStatusRule* temp = traj_status_;
  traj_status_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.IsStayRule is_stay = 6;
inline bool Rule::has_is_stay() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Rule::set_has_is_stay() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Rule::clear_has_is_stay() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Rule::clear_is_stay() {
  if (is_stay_ != NULL) is_stay_->::lbs::da::openservice::IsStayRule::Clear();
  clear_has_is_stay();
}
inline const ::lbs::da::openservice::IsStayRule& Rule::is_stay() const {
  return is_stay_ != NULL ? *is_stay_ : *default_instance_->is_stay_;
}
inline ::lbs::da::openservice::IsStayRule* Rule::mutable_is_stay() {
  set_has_is_stay();
  if (is_stay_ == NULL) is_stay_ = new ::lbs::da::openservice::IsStayRule;
  return is_stay_;
}
inline ::lbs::da::openservice::IsStayRule* Rule::release_is_stay() {
  clear_has_is_stay();
  ::lbs::da::openservice::IsStayRule* temp = is_stay_;
  is_stay_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.PoiRule poi = 7;
inline bool Rule::has_poi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Rule::set_has_poi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Rule::clear_has_poi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Rule::clear_poi() {
  if (poi_ != NULL) poi_->::lbs::da::openservice::PoiRule::Clear();
  clear_has_poi();
}
inline const ::lbs::da::openservice::PoiRule& Rule::poi() const {
  return poi_ != NULL ? *poi_ : *default_instance_->poi_;
}
inline ::lbs::da::openservice::PoiRule* Rule::mutable_poi() {
  set_has_poi();
  if (poi_ == NULL) poi_ = new ::lbs::da::openservice::PoiRule;
  return poi_;
}
inline ::lbs::da::openservice::PoiRule* Rule::release_poi() {
  clear_has_poi();
  ::lbs::da::openservice::PoiRule* temp = poi_;
  poi_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.AoiRule aoi = 8;
inline bool Rule::has_aoi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Rule::set_has_aoi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Rule::clear_has_aoi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Rule::clear_aoi() {
  if (aoi_ != NULL) aoi_->::lbs::da::openservice::AoiRule::Clear();
  clear_has_aoi();
}
inline const ::lbs::da::openservice::AoiRule& Rule::aoi() const {
  return aoi_ != NULL ? *aoi_ : *default_instance_->aoi_;
}
inline ::lbs::da::openservice::AoiRule* Rule::mutable_aoi() {
  set_has_aoi();
  if (aoi_ == NULL) aoi_ = new ::lbs::da::openservice::AoiRule;
  return aoi_;
}
inline ::lbs::da::openservice::AoiRule* Rule::release_aoi() {
  clear_has_aoi();
  ::lbs::da::openservice::AoiRule* temp = aoi_;
  aoi_ = NULL;
  return temp;
}

// optional .lbs.da.openservice.StrMatchRule str_rule = 100;
inline bool Rule::has_str_rule() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Rule::set_has_str_rule() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Rule::clear_has_str_rule() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Rule::clear_str_rule() {
  if (str_rule_ != NULL) str_rule_->::lbs::da::openservice::StrMatchRule::Clear();
  clear_has_str_rule();
}
inline const ::lbs::da::openservice::StrMatchRule& Rule::str_rule() const {
  return str_rule_ != NULL ? *str_rule_ : *default_instance_->str_rule_;
}
inline ::lbs::da::openservice::StrMatchRule* Rule::mutable_str_rule() {
  set_has_str_rule();
  if (str_rule_ == NULL) str_rule_ = new ::lbs::da::openservice::StrMatchRule;
  return str_rule_;
}
inline ::lbs::da::openservice::StrMatchRule* Rule::release_str_rule() {
  clear_has_str_rule();
  ::lbs::da::openservice::StrMatchRule* temp = str_rule_;
  str_rule_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Condition

// repeated .lbs.da.openservice.Rule rules = 1;
inline int Condition::rules_size() const {
  return rules_.size();
}
inline void Condition::clear_rules() {
  rules_.Clear();
}
inline const ::lbs::da::openservice::Rule& Condition::rules(int index) const {
  return rules_.Get(index);
}
inline ::lbs::da::openservice::Rule* Condition::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::lbs::da::openservice::Rule* Condition::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >&
Condition::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Rule >*
Condition::mutable_rules() {
  return &rules_;
}

// optional string append = 2;
inline bool Condition::has_append() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Condition::set_has_append() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Condition::clear_has_append() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Condition::clear_append() {
  if (append_ != &::google::protobuf::internal::kEmptyString) {
    append_->clear();
  }
  clear_has_append();
}
inline const ::std::string& Condition::append() const {
  return *append_;
}
inline void Condition::set_append(const ::std::string& value) {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  append_->assign(value);
}
inline void Condition::set_append(const char* value) {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  append_->assign(value);
}
inline void Condition::set_append(const char* value, size_t size) {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  append_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_append() {
  set_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    append_ = new ::std::string;
  }
  return append_;
}
inline ::std::string* Condition::release_append() {
  clear_has_append();
  if (append_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = append_;
    append_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tag = 3;
inline bool Condition::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Condition::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Condition::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Condition::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Condition::tag() const {
  return *tag_;
}
inline void Condition::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Condition::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Condition::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Condition::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RegistInfo

// optional string cuid = 1;
inline bool RegistInfo::has_cuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistInfo::set_has_cuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistInfo::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistInfo::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& RegistInfo::cuid() const {
  return *cuid_;
}
inline void RegistInfo::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void RegistInfo::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void RegistInfo::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistInfo::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* RegistInfo::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lbs.da.openservice.Condition cond = 2;
inline bool RegistInfo::has_cond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistInfo::set_has_cond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistInfo::clear_has_cond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistInfo::clear_cond() {
  if (cond_ != NULL) cond_->::lbs::da::openservice::Condition::Clear();
  clear_has_cond();
}
inline const ::lbs::da::openservice::Condition& RegistInfo::cond() const {
  return cond_ != NULL ? *cond_ : *default_instance_->cond_;
}
inline ::lbs::da::openservice::Condition* RegistInfo::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) cond_ = new ::lbs::da::openservice::Condition;
  return cond_;
}
inline ::lbs::da::openservice::Condition* RegistInfo::release_cond() {
  clear_has_cond();
  ::lbs::da::openservice::Condition* temp = cond_;
  cond_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RegistConditionRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool RegistConditionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistConditionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistConditionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistConditionRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& RegistConditionRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* RegistConditionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* RegistConditionRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .lbs.da.openservice.RegistInfo regist_info = 2;
inline int RegistConditionRequest::regist_info_size() const {
  return regist_info_.size();
}
inline void RegistConditionRequest::clear_regist_info() {
  regist_info_.Clear();
}
inline const ::lbs::da::openservice::RegistInfo& RegistConditionRequest::regist_info(int index) const {
  return regist_info_.Get(index);
}
inline ::lbs::da::openservice::RegistInfo* RegistConditionRequest::mutable_regist_info(int index) {
  return regist_info_.Mutable(index);
}
inline ::lbs::da::openservice::RegistInfo* RegistConditionRequest::add_regist_info() {
  return regist_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegistInfo >&
RegistConditionRequest::regist_info() const {
  return regist_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::RegistInfo >*
RegistConditionRequest::mutable_regist_info() {
  return &regist_info_;
}

// required .lbs.da.openservice.Operation operation = 3;
inline bool RegistConditionRequest::has_operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistConditionRequest::set_has_operation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistConditionRequest::clear_has_operation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistConditionRequest::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline lbs::da::openservice::Operation RegistConditionRequest::operation() const {
  return static_cast< lbs::da::openservice::Operation >(operation_);
}
inline void RegistConditionRequest::set_operation(lbs::da::openservice::Operation value) {
  GOOGLE_DCHECK(lbs::da::openservice::Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// -------------------------------------------------------------------

// RegistConditionResponse

// optional bool is_success = 1;
inline bool RegistConditionResponse::has_is_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistConditionResponse::set_has_is_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistConditionResponse::clear_has_is_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistConditionResponse::clear_is_success() {
  is_success_ = false;
  clear_has_is_success();
}
inline bool RegistConditionResponse::is_success() const {
  return is_success_;
}
inline void RegistConditionResponse::set_is_success(bool value) {
  set_has_is_success();
  is_success_ = value;
}

// optional int32 num = 2;
inline bool RegistConditionResponse::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistConditionResponse::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistConditionResponse::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistConditionResponse::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 RegistConditionResponse::num() const {
  return num_;
}
inline void RegistConditionResponse::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional string error = 3;
inline bool RegistConditionResponse::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistConditionResponse::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistConditionResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistConditionResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& RegistConditionResponse::error() const {
  return *error_;
}
inline void RegistConditionResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void RegistConditionResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void RegistConditionResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistConditionResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* RegistConditionResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Trigger

// optional string tag = 1;
inline bool Trigger::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trigger::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trigger::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trigger::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Trigger::tag() const {
  return *tag_;
}
inline void Trigger::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Trigger::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Trigger::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trigger::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Trigger::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string post_url = 2;
inline bool Trigger::has_post_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trigger::set_has_post_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trigger::clear_has_post_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trigger::clear_post_url() {
  if (post_url_ != &::google::protobuf::internal::kEmptyString) {
    post_url_->clear();
  }
  clear_has_post_url();
}
inline const ::std::string& Trigger::post_url() const {
  return *post_url_;
}
inline void Trigger::set_post_url(const ::std::string& value) {
  set_has_post_url();
  if (post_url_ == &::google::protobuf::internal::kEmptyString) {
    post_url_ = new ::std::string;
  }
  post_url_->assign(value);
}
inline void Trigger::set_post_url(const char* value) {
  set_has_post_url();
  if (post_url_ == &::google::protobuf::internal::kEmptyString) {
    post_url_ = new ::std::string;
  }
  post_url_->assign(value);
}
inline void Trigger::set_post_url(const char* value, size_t size) {
  set_has_post_url();
  if (post_url_ == &::google::protobuf::internal::kEmptyString) {
    post_url_ = new ::std::string;
  }
  post_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trigger::mutable_post_url() {
  set_has_post_url();
  if (post_url_ == &::google::protobuf::internal::kEmptyString) {
    post_url_ = new ::std::string;
  }
  return post_url_;
}
inline ::std::string* Trigger::release_post_url() {
  clear_has_post_url();
  if (post_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = post_url_;
    post_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SetTriggerRequest

// required .lbs.da.openservice.RequestHeader header = 1;
inline bool SetTriggerRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTriggerRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTriggerRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTriggerRequest::clear_header() {
  if (header_ != NULL) header_->::lbs::da::openservice::RequestHeader::Clear();
  clear_has_header();
}
inline const ::lbs::da::openservice::RequestHeader& SetTriggerRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::lbs::da::openservice::RequestHeader* SetTriggerRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::lbs::da::openservice::RequestHeader;
  return header_;
}
inline ::lbs::da::openservice::RequestHeader* SetTriggerRequest::release_header() {
  clear_has_header();
  ::lbs::da::openservice::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .lbs.da.openservice.Trigger trigger = 2;
inline int SetTriggerRequest::trigger_size() const {
  return trigger_.size();
}
inline void SetTriggerRequest::clear_trigger() {
  trigger_.Clear();
}
inline const ::lbs::da::openservice::Trigger& SetTriggerRequest::trigger(int index) const {
  return trigger_.Get(index);
}
inline ::lbs::da::openservice::Trigger* SetTriggerRequest::mutable_trigger(int index) {
  return trigger_.Mutable(index);
}
inline ::lbs::da::openservice::Trigger* SetTriggerRequest::add_trigger() {
  return trigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Trigger >&
SetTriggerRequest::trigger() const {
  return trigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::lbs::da::openservice::Trigger >*
SetTriggerRequest::mutable_trigger() {
  return &trigger_;
}

// required .lbs.da.openservice.Operation operation = 3;
inline bool SetTriggerRequest::has_operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetTriggerRequest::set_has_operation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetTriggerRequest::clear_has_operation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetTriggerRequest::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline lbs::da::openservice::Operation SetTriggerRequest::operation() const {
  return static_cast< lbs::da::openservice::Operation >(operation_);
}
inline void SetTriggerRequest::set_operation(lbs::da::openservice::Operation value) {
  GOOGLE_DCHECK(lbs::da::openservice::Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
}

// -------------------------------------------------------------------

// SetTriggerResponse

// optional bool is_success = 1;
inline bool SetTriggerResponse::has_is_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTriggerResponse::set_has_is_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTriggerResponse::clear_has_is_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTriggerResponse::clear_is_success() {
  is_success_ = false;
  clear_has_is_success();
}
inline bool SetTriggerResponse::is_success() const {
  return is_success_;
}
inline void SetTriggerResponse::set_is_success(bool value) {
  set_has_is_success();
  is_success_ = value;
}

// optional int32 num = 2;
inline bool SetTriggerResponse::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetTriggerResponse::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetTriggerResponse::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetTriggerResponse::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 SetTriggerResponse::num() const {
  return num_;
}
inline void SetTriggerResponse::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional string error = 3;
inline bool SetTriggerResponse::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetTriggerResponse::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetTriggerResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetTriggerResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& SetTriggerResponse::error() const {
  return *error_;
}
inline void SetTriggerResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void SetTriggerResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void SetTriggerResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetTriggerResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* SetTriggerResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace openservice
}  // namespace da
}  // namespace lbs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::RuleType>() {
  return lbs::da::openservice::RuleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lbs::da::openservice::Operation>() {
  return lbs::da::openservice::Operation_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_regist_5fcondition_2eproto__INCLUDED
